<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：vim | Code Rush]]></title>
  <link href="http://notice501.github.com/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://notice501.github.com/"/>
  <updated>2014-04-22T23:12:11+08:00</updated>
  <id>http://notice501.github.com/</id>
  <author>
    <name><![CDATA[foocoder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[每日vim插件--文件浏览器NERD Tree以及git-nerdtree,vim-nerdtree-tabs]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs.html/"/>
    <updated>2014-04-22T19:43:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs</id>
    <content type="html"><![CDATA[<p>今天介绍一个必备插件——<a href="https://github.com/scrooloose/nerdtree">NERD Tree</a>。这个插件基本用vim的都会知道吧。看图就知道了：
<img src="http://ww2.sinaimg.cn/large/69d56e38gw1efoqvqpramj21gu12i46s.jpg" alt="" /></p>

<p>用它可以让vim像其他大多数编辑器或者IDE一样，打开一个分割窗口显示文件树，在这个文件树上可以通过<code>j</code>,<code>k</code>上下浏览以及其他一些快捷键进行快速文件导航。按回车就直接打开该文件，当然还可以通过<code>i</code>,<code>s</code>,<code>t</code>在分隔窗口或者在新标签页打开.</p>

<!--more-->

<p>NERD Tree还支持书签。所谓书签，就是标记该文件或文件夹会优先显示在最上方。如前面图中的_posts文件夹。只要光标在该文件上输入命令<code>:Bookmark &lt;name&gt;</code>.非常方便</p>

<p>NERD Tree不想介绍过多，使用非常简单。在NerdTree窗口按下问号就会有帮助信息介绍所有的操作和对应的快捷键，常用下很快就很熟了。</p>

<p>NERD Tree有个问题在于和大多数IDE或者编辑器不同的是，在新的Tab中，NERD Tree默认是不打开的。不同的tab不能共享一个NERD Tree窗口，有人对这种方式可能就比较别扭。这时候就诞生了<a href="https://github.com/jistr/vim-nerdtree-tabs">vim-nerdtree-tabs</a>.该插件就解决了这个问题，它让每个tab都有相同的NERD Tree，看起来就像NERD Tree固定在最左一样。按下<code>:NERDTreeTabsToggle</code>就可以打开或关闭所有窗口。关闭文件窗口的时候，对于tab的NERD Tree窗口也会自动关闭。</p>

<p>接下来介绍的<a href="https://github.com/Xuyuanp/git-nerdtree">git-nerdtree</a>是来自@Xuyuanp的作品,通过微信公众号介绍给我。也是对NERD Tree的增强修改，增加了文件的git状态显示，和昨天的gitgutter类似，Gitgutter显示文件内的git diff，而git-nerdtree为NERD Tree增加了文件git状态的显示：</p>

<p><img src="https://camo.githubusercontent.com/3fe0388df11cb787f36e1fa108398fd3f757eef4/687474703a2f2f692e696d6775722e636f6d2f6a534377476a552e6769663f31" alt="" /></p>

<p>相对应的标识如下：</p>

<ul>
  <li><code>✭</code> / <code>*</code> : Untracked</li>
  <li><code>✹</code> / <code>~</code> : Modified in the working tree</li>
  <li><code>✚</code> / <code>+</code> : Staged in the index (Exclude Renamed status)</li>
  <li><code>➜</code> / <code>»</code> : Renamed</li>
  <li><code>═</code> / <code>=</code> : Unmerged</li>
  <li><code>✖</code> / <code>-</code> : Deleted (This indicator can’t be shown, as NERDTree doesn’t display deleted files. I have no prefect idea to solve this problem currently.)</li>
  <li><code>✗</code> / <code>×</code> : Dirty (Only for directory)</li>
  <li><code>✔</code> / <code>ø</code> : Clean (Only for directory)</li>
</ul>

<p>标识方式和我之前介绍的zsh配置对git库状态的处理类似（可以查看我之前的博客）。</p>

<p>同时还支持和gitgutter一样的快捷键在各个有状态的文件之间跳转<code>[c</code>,<code>]c</code>.我只能说太棒了，再次感谢@Xuyuanp。</p>

<p>今天就介绍到这里，任何问题都可以直接回复。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--快速选择文本对象wildfile.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim.html/"/>
    <updated>2014-04-18T20:06:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim</id>
    <content type="html"><![CDATA[<p>之前我们介绍了文本对象，并介绍了两个自定义文本对象的插件。今天介绍的插件也和文本对象有关。他可以用来快速的就近选择一个候选文本对象，并能通过快捷键继续简单的扩大文本对象范围。</p>

<p>这个插件就是–<a href="https://github.com/Shougo/wildfire.vim">wildfire</a>（给的是shougo fork的repo地址，比较喜欢shougo这个插件作者，而且这个fork fix了一个bug）</p>

<p>插件默认定义的候选文本对象为：</p>

<pre><code> `i'`, `i"`, `i)`, `i]`, `i}`, `ip` and `it`
</code></pre>

<p>来一张官方图</p>

<!--more-->

<p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efk07xfk7kg20jv087myy.gif" alt="" /></p>

<p>有图应该大家能理解这个插件的作用了。</p>

<p>使用方式也非常简单，按<code>enter</code>选择最近一个文本对象，再按下<code>enter</code>在刚刚的选择之上再选择最近的文本对象。按下<code>&lt;BS&gt;</code>就能回退到上一个选择。</p>

<p>当然，你可以自定义快捷键：</p>

<p>```vim
“ This selects the next closest text object.
let g:wildfire_fuel_map = “<enter>"</enter></p>

<p>” This selects the previous closest text object.
let g:wildfire_water_map = “<bs>"
```</bs></p>

<p>候选的文本对象也是可以配置的：</p>

<p><code>vim
let g:wildfire_objects = ["i'", 'i"', "i)", "i]", "i}", "ip", "it"]
</code></p>

<p>插件还支持对文件类型分别定义，比如要在html中只处理tag，忽略其他文本对象，只需要配置：</p>

<p><code>vim
" use '*' to mean 'all other filetypes'
" in this example, html and xml share the same text objects
let g:wildfire_objects = {
    \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
    \ "html,xml" : ["at"],
\ }
</code></p>

<p>与之类似的一个用的相当广泛的插件还有<a href="https://github.com/terryma/vim-expand-region">vim-expand-region</a>。大家可以自己选择。有问题欢迎留言或回复交流。也希望大家推荐自己在用，自己写的插件给我。今天看到一个朋友微信回复我的一个他自己写的插件，我已经立刻用上了，卖个关子，下次介绍。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--可以重复motion的space.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim.html/"/>
    <updated>2014-04-17T21:10:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim</id>
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efiwusn0uhj20m80godg5.jpg" style="height: 400px;" /></p>

<p>今天头疼的厉害。不过昨天没更新，今天必须有了。介绍个简单点的。</p>

<p>vim中在普通模式下，空格这么大一按键不用有点浪费，所以有了<a href="https://github.com/spiiph/vim-space">space.vim</a>.</p>

<!--more-->

<p>他能重复执行motion，比如</p>

<pre><code>*Hello World
</code></pre>

<p>按下<code>fo</code>,会将光标移动到第一个o上，再按下空格，就能移动到第二个o了，他会重复执行上一个<code>fo</code>。按下<code>&lt;Shift-Space&gt;</code>反向执行改操作，也就是光标又会回到第一个<code>o</code>.</p>

<p>除此之外，space.vim还能重复搜索命令，diff移动命令，qucikfix等操作。让空格键变的非常有用.下面是space.vim可以重复的全部命令列表：</p>

<p>```
Character movements:                                    |left-right-motions|
    |f| |F| |t| |T| |;| |,|</p>

<table>
  <tbody>
    <tr>
      <td>Search commands:</td>
      <td>search-commands</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>star</td>
      <td> </td>
      <td>gstar</td>
      <td> </td>
      <td>#</td>
      <td> </td>
      <td>g#</td>
      <td> </td>
      <td>n</td>
      <td> </td>
      <td>N</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Jump list jumps:</td>
      <td>jump-motions</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-O</td>
      <td> </td>
      <td>CTRL-I</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Change list jumps:</td>
      <td>change-list-jumps</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g;</td>
      <td> </td>
      <td>g,</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Diff jumps:</td>
      <td>jumpto-diffs</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]c</td>
      <td> </td>
      <td>[c</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Parenthesis and bracket jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>])</td>
      <td> </td>
      <td>[(</td>
      <td> </td>
      <td>]}</td>
      <td> </td>
      <td>[{</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Method jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]m</td>
      <td> </td>
      <td>[m</td>
      <td> </td>
      <td>]M</td>
      <td> </td>
      <td>[M</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Section jumps:</td>
      <td>object-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]]</td>
      <td> </td>
      <td>[]</td>
      <td> </td>
      <td>][</td>
      <td> </td>
      <td>[[</td>
    </tr>
  </tbody>
</table>

<p>Fold movements:
    |zj| |zk| |]z| |[z|</p>

<table>
  <tbody>
    <tr>
      <td>Tag movements:</td>
      <td>tag-commands</td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-]</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tag</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:trewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tlast</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Undolist movements:</td>
      <td>undo-branches</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g-</td>
      <td> </td>
      <td>g+</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Quickfix commands:</td>
      <td>quickfix</td>
    </tr>
    <tr>
      <td> </td>
      <td>:make</td>
    </tr>
    <tr>
      <td> </td>
      <td>:vimgrep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:grep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cc</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:clast</td>
    </tr>
    <tr>
      <td> </td>
      <td>:crewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cpfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNfile</td>
    </tr>
  </tbody>
</table>

<p>Location list commands:                                      |location-list|
    |:lmake|
    |:lvimgrep|
    |:lgrep|
    |:ll|
    |:lcnext|
    |:lcprevious|
    |:lcNext|
    |:lcfirst|
    |:lclast|
    |:lcrewind|
    |:lcfile|
    |:lcnfile|
    |:lcpfile|
    |:lcNfile|
```</p>

<p>今天解介绍到这里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--vim 撤销树Gundo.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim.html/"/>
    <updated>2014-04-15T21:10:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim</id>
    <content type="html"><![CDATA[<p>今天介绍的插件很有意思，也非常有用，也是我最常用的插件之一——<a href="https://github.com/sjl/gundo.vim">Gundo</a>.</p>

<p>大家都知道按<code>u</code>可以撤销操作，但是一般都不知道输入命令<code>:undolist</code>会显示可撤销列表，如图</p>

<p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efglaef02lj20ki13qthg.jpg" style="     height: 600px; " /> </p>

<p>其实这还不是列表，而是整个vim 撤销树的叶子。为什么说是树，而不是列表，举个例子就明白了：</p>

<!--more-->

<p>你在a状态做了一次修改到b，又回退到a，再做了一次修改到c。大多数编辑器比如sublime text，b这个状态就没了，但是vim会用一个树进行保存。</p>

<p>而Gundo这个插件就是一个撤销树浏览器.直接上张图：</p>

<p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efgmev2lz4j20ok1ci78i.jpg" style="     height: 600px; " /></p>

<p>当前位置以<code>@</code>标注，其他历史以o标注。</p>

<p>按jk上下移动，就可以在下面的窗口看到对应修改之前的改动。这个就是普通的vim窗口，所有的移动操作都是支持的，比如<code>G</code>到底部，<code>C-U</code>上翻页等。</p>

<p>按<code>p</code>可以查看选中状态和当前状态的差异，按回车就会回到选中状态，按<code>P</code>更是可以一步步播放到选中状态，高上大啊……</p>

<p>btw,我习惯将所有的undo记录都保存下来，即使关闭了vim或者buffer也能继续撤销。</p>

<p>只需要稍加配置，就能将撤销树持久化存储下来：</p>

<p><code>vim
try
    set undodir=~/.vim/temp_dirs/undodir
    set undofile
catch
endtry
</code></p>

<p>今天就介绍到这里。有问题直接回复给我。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--vim中的文本对象及相关插件]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian.html/"/>
    <updated>2014-04-14T22:56:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian</id>
    <content type="html"><![CDATA[<p>今天按读者留言的要求，介绍下文本对象。同时还会介绍我在用的几个文本相关的插件，今天是满满的内容啊。</p>

<p>所谓文本对象，简单来说就是以一定标准分隔符来标识一段文本，比如一个单词，一句话，一段话。</p>

<p>使用文本对象后你会发现你在vim中的移动和操作速度提升了不是一点半点。</p>

<p>在vim中编辑命令的结构如下：</p>

<pre><code> &lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;
</code></pre>

<p>可以看到文本对象和motion的操作是完全一致的，第一个是数字，比如3w，就向前移动三个单词。</p>

<!--more-->

<p>文本对象大致有以下几种：</p>

<pre><code>w  s  p '' ""  &lt;&gt;  []  ()  {} &lt;tag&gt;
</code></pre>

<p>其中w表示word，s表示句子，p表示段落，其他的就是昨天介绍过的包围符号，标签用t表示。</p>

<p>文本对象的操作范围有两种，一种用<code>i</code>表示,是inner的意思，即不包括单词边上的空格符，亦或是<code>&lt;</code>包围符号本身。一种用<code>a</code>表示，是arround的意思，和i相反，使用a就包括了空格符或者包围符号本身。</p>

<p>文本对象的编辑命令就是vim中的几个常用编辑命令，分别是</p>

<pre><code>`y：复制`，`d：删除`,`c：替换`，`v：选中`
</code></pre>

<p>说的有点多了，来几个例子相信大家就立刻理解了。（例子中*都是光标所在位置）</p>

<p>比如：</p>

<pre><code>&lt;*h2&gt;Sample Title&lt;/h2&gt;
</code></pre>

<p>按下<code>cit</code>,文本变为：</p>

<pre><code>&lt;h2&gt;*&lt;/h2&gt;
</code></pre>

<p>再比如：
	console.log(“stay hungry,” + “stay *foolish”)</p>

<p>按下<code>da"</code>，文本变为：</p>

<pre><code>console.log("stay hungry," +*)
</code></pre>

<p>再按下<code>di)</code>，文本变为：</p>

<pre><code>console.log()
</code></pre>

<p>比如</p>

<pre><code>Hello Worl*d
</code></pre>

<p>按下<code>diw</code>,文本变为：</p>

<pre><code>Hello
</code></pre>

<p>很容易理解是不是？有没有发现为什么说文本对象会非常方便了？无论光标在文本的哪个位置，都可以直接操作整个文本。体验箭步如飞的感觉吧。</p>

<p>vim还允许使用脚本来自定义文本对象，这就是我们今天要介绍的插件了，这些插件自定义了一些文本对象。</p>

<p>1.CamelCaseMotion</p>

<p>该插件是把驼峰词语的每个单词分开，举个例子：</p>

<pre><code>get*ElementsByClassName
</code></pre>

<p>按下<code>di,w</code>,则文本变为：</p>

<pre><code>getByClassName
</code></pre>

<p>非常方便。</p>

<p>2.argtextobj</p>

<p>该插件定义了函数内的参数文本对象。比如：</p>

<pre><code>foo(text, ti*mes, option) {}
</code></pre>

<p>按下<code>daa</code>,则文本变为：</p>

<pre><code>foo(text, option) {}
</code></pre>

<p>今天暂时就介绍到这里。都快0点了，赶紧发出来。任何问题都可以回复给我。	</p>

]]></content>
  </entry>
  
</feed>
