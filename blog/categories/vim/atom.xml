<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：vim | Code Rush]]></title>
  <link href="http://notice501.github.com/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://notice501.github.com/"/>
  <updated>2014-05-13T20:20:53+08:00</updated>
  <id>http://notice501.github.com/</id>
  <author>
    <name><![CDATA[foocoder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[每日vim插件--平滑滚动accelerated-smooth-scroll.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-ping-hua-gun-dong-accelerated-smooth-scroll-dot-vim.html/"/>
    <updated>2014-04-29T22:11:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-ping-hua-gun-dong-accelerated-smooth-scroll-dot-vim</id>
    <content type="html"><![CDATA[<p>今天介绍一个简单的插件：<a href="https://github.com/yonchu/accelerated-smooth-scroll">accelerated-smooth-scroll.</a>
很简单，就是让<code>&lt;C-D&gt;/&lt;C-U&gt;</code>和<code>&lt;C-F&gt;/&lt;C-B&gt;</code>不再突然出现，而是出现滚动效果。同时，在连续滚动时，还有加速效果。
做了个gif图，真实效果比图片要更流畅一些，如图所示：</p>

<p><img src="http://ww4.sinaimg.cn/large/69d56e38gw1efwtsjauuag20qj0ivkjm.gif" alt="" /></p>

<p>今天就介绍它啦。几乎是用的最多的插件……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--强大的自动补全neocomplete.vim和supertab]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-qiang-da-de-zi-dong-bu-quan-neocomplete-dot-vim.html/"/>
    <updated>2014-04-28T21:02:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-qiang-da-de-zi-dong-bu-quan-neocomplete-dot-vim</id>
    <content type="html"><![CDATA[<h1 id="neocompletevim">neocomplete.vim</h1>

<p>今天介绍两个个必备的vim插件，自动补全插件——<a href="https://github.com/Shougo/neocomplete.vim">neocomplete.vim</a>和superTab。</p>

<p>neocomplete.vim是来自shougo的作品。该插件维护了当前buffer的一个关键词列表，从而提供强大的关键词补全功能。</p>

<p>该插件是他前作neocomplcache的升级版，速度更快，功能更强大。不过该插件需要<a href="http://vimdoc.sourceforge.net/htmldoc/if_lua.html">if_lua</a>的支持。</p>

<p>mac下安装：</p>

<pre><code>brew install macvim --with-cscope --with-lua --HEAD
</code></pre>

<p>或者不用macvim（真的不用么？赶紧试试吧）：</p>

<pre><code>brew install vim --with-lua
</code></pre>

<p>不需要过多的介绍,看作者给的图：</p>

<!--more-->

<h3 id="section">文件补全</h3>

<p><img src="https://f.cloud.github.com/assets/41495/622454/f519f6b8-cf42-11e2-921e-6e34dba148a6.png" alt="Original filename completion." />
<img src="https://f.cloud.github.com/assets/214488/623151/284ad86e-cf5b-11e2-828e-257d31bf0572.png" alt="Include filename completion." /></p>

<h3 id="omni-">Omni 补全</h3>

<p><img src="https://f.cloud.github.com/assets/41495/622456/fb2cc0bc-cf42-11e2-94e8-403cdcf5427e.png" alt="Omni completion." /></p>

<h3 id="vimshellhttpgithubcomshougovimshell"><a href="http://github.com/Shougo/vimshell">vimshell</a>补全</h3>

<p><img src="https://f.cloud.github.com/assets/41495/622458/01dbc660-cf43-11e2-85f1-326e7432b0a1.png" alt="Completion with vimshell(http://github.com/Shougo/vimshell)." /></p>

<h3 id="vim-">Vim 补全</h3>

<p><img src="https://f.cloud.github.com/assets/41495/622457/fe90ad5e-cf42-11e2-8e03-8f189b5e26e5.png" alt="Vim completion." />
<img src="https://f.cloud.github.com/assets/214488/623496/94ed19a2-cf68-11e2-8d33-3aad8a39d7c1.gif" alt="Vim completion with animation." /></p>

<p>作者还给出了推荐配置，每个配置都有对应的英文注释，我就不一一翻译了：</p>

<p>```vim
“Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
“ Disable AutoComplPop.
let g:acp_enableAtStartup = 0
“ Use neocomplete.
let g:neocomplete#enable_at_startup = 1
“ Use smartcase.
let g:neocomplete#enable_smart_case = 1
“ Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = ‘*ku*’</p>

<p>” Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ ‘default’ : ‘’,
    \ ‘vimshell’ : $HOME.’/.vimshell_hist’,
    \ ‘scheme’ : $HOME.’/.gosh_completions’
        \ }</p>

<p>” Define keyword.
if !exists(‘g:neocomplete#keyword_patterns’)
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns[‘default’] = ‘\h\w*’</p>

<p>” Plugin key-mappings.
inoremap <expr><c-g>     neocomplete#undo_completion()
inoremap <expr><c-l>     neocomplete#complete_common_string()</c-l></expr></c-g></expr></p>

<p>” Recommended key-mappings.
“ <cr>: close popup and save indent.
inoremap <silent> <cr> <c-r>=<sid>my_cr_function()<cr>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<cr>"
  " For no inserting <cr> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<cr>"
endfunction
" <tab>: completion.
inoremap <expr><tab>  pumvisible() ? "\<c-n>" : "\<tab>"
" <c-h>, <bs>: close popup and delete backword char.
inoremap <expr><c-h> neocomplete#smart_close_popup()."\<c-h>"
inoremap <expr><bs> neocomplete#smart_close_popup()."\<c-h>"
inoremap <expr><c-y>  neocomplete#close_popup()
inoremap <expr><c-e>  neocomplete#cancel_popup()
" Close popup by <space>.
"inoremap <expr><space> pumvisible() ? neocomplete#close_popup() : "\<space>"</space></space></expr></space></c-e></expr></c-y></expr></c-h></bs></expr></c-h></c-h></expr></bs></c-h></tab></c-n></tab></expr></tab></cr></cr></cr></cr></sid></c-r></cr></silent></cr></p>

<p>” For cursor moving in insert mode(Not recommended)
“inoremap <expr><left>  neocomplete#close_popup() . "\<left>"
"inoremap <expr><right> neocomplete#close_popup() . "\<right>"
"inoremap <expr><up>    neocomplete#close_popup() . "\<up>"
"inoremap <expr><down>  neocomplete#close_popup() . "\<down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1</down></down></expr></up></up></expr></right></right></expr></left></left></expr></p>

<p>” AutoComplPop like behavior.
“let g:neocomplete#enable_auto_select = 1</p>

<p>” Shell like behavior(not recommended).
“set completeopt+=longest
“let g:neocomplete#enable_auto_select = 1
“let g:neocomplete#disable_auto_complete = 1
“inoremap <expr><tab>  pumvisible() ? "\<down>" : "\<c-x>\<c-u>"</c-u></c-x></down></tab></expr></p>

<p>” Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags</p>

<p>” Enable heavy omni completion.
if !exists(‘g:neocomplete#sources#omni#input_patterns’)
  let g:neocomplete#sources#omni#input_patterns = {}
endif
“let g:neocomplete#sources#omni#input_patterns.php = ‘[^. \t]-&gt;\h\w<em>|\h\w</em>::’
“let g:neocomplete#sources#omni#input_patterns.c = ‘[^.[:digit:] <em>\t]\%(.|-&gt;)’
“let g:neocomplete#sources#omni#input_patterns.cpp = ‘[^.[:digit:] *\t]\%(.|-&gt;)|\h\w</em>::’</p>

<p>” For perlomni.vim setting.
“ https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = ‘\h\w<em>-&gt;\h\w</em>|\h\w*::’
```</p>

<p>没有特殊需求，直接copy就用即可。没有复杂的配置，用起来还是非常简单的。</p>

<p>还有一个比较出名的补全插件是<a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>.大家也可以去看下，应该是现在用的最广泛的补全插件了。我很早就试用过，还是neocomplete要更顺手更快些，总感觉neocomplete要更智能些。</p>

<h1 id="supertab">superTab</h1>

<p>说到补全还有个不得不说，那就是tab键，必须用tab来进行补全那才是补全啊。其实neocomplete的推荐配置已经配置成了自动提示补全文字，并且支持tab选择，但是还是无法<code>shift-tab</code>回退选择。superTab就是为增强tab而生，当然可以做到这点。</p>

<p>superTab 和neocomplete一样，几乎不用自己折腾什么配置，也不用过多的介绍，一句话就可以说完它的功能。</p>

<pre><code>bar
baz
b*&lt;Tab&gt; (*为光标所在位置) 
</code></pre>

<p>按示例在光标处按下tab，就会展开推荐补全bar和baz，按tab即可进行循环选择。</p>

<p>可以配置supertab的默认补全类型（对vim补全不了解的同学自己补下omni补全相关知识，需要我介绍可以回复下）：</p>

<pre><code>let g:SuperTabDefaultCompletionType = "&lt;c-x&gt;&lt;c-u&gt;"
</code></pre>

<p>示例把supertab修改为了用户补全，默认是<code>&lt;c-p&gt;</code>.</p>

<p>今天就介绍到这里。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--Gist.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-gist-dot-vim.html/"/>
    <updated>2014-04-25T19:58:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-gist-dot-vim</id>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efs6kvu5zpj20m80go3z0.jpg" alt="" />
今天介绍的插件<a href="https://github.com/mattn/gist-vim">Gist.vim</a>能够在vim中方便的创建和查看gist。</p>

<p>gist我就不过多介绍了，github提供的一个代码片段托管服务。不太了解的同学可以看看<a href="http://www.worldhello.net/gotgithub/06-side-projects/gist.html">这个教程</a></p>

<p>要使用这个插件需要安装ygie依赖插件：</p>

<p><code>vim
Bundle 'mattn/webapi-vim'
Bundle 'mattn/gist-vim'
</code></p>

<p>确保在git的global配置中设置的是github用户名：</p>

<pre><code>$ git config --global github.user &lt;username&gt;
</code></pre>

<p>该插件在首次使用时会需要你输入github密码来获取token，并将其保存在<code>~/.gist-vim</code>.</p>

<!--more-->

<p>使用非常的简单，输入命令</p>

<p><code>
:Gist
</code></p>

<p>就会将该整个文件创建一个Gist，创建成功后会显示Gist地址，如图：
<img src="http://ww3.sinaimg.cn/large/69d56e38gw1efs60clnedj20my040gm2.jpg" alt="" /></p>

<p>也可以选中一段代码创建Gist：</p>

<p><code>
 :'&lt;,'&gt;Gist
</code></p>

<p>还提供了一些参数</p>

<p>例如<code>-a</code>,表示匿名创建，<code>-p</code>创建pravite 的gist，<code>-P</code>创建public的gist。<code>-m</code>为所有打开的buffer创建Gist。</p>

<p>除此之外，还可以编辑Gist(已打开了一个gist buffer的情况下)</p>

<p><code>
:Gist -e
</code>
加上描述</p>

<p><code>
:Gist -s something
</code></p>

<p>删除：</p>

<p><code>
:Gist -d
</code></p>

<p>fork:</p>

<p><code>
:Gist -f
</code></p>

<p>star:</p>

<p><code>
:Gist +1
</code></p>

<p>unstar:</p>

<p><code>
:Gist -1
</code></p>

<p>还可以直接取得Gist：</p>

<p><code>
:Gist XXXXX
</code></p>

<p>一般你不记得gist号码，没关系，还可以列出所有的Gist,</p>

<p><code>
:Gist -l
</code></p>

<p>这样会打开一个新的分隔窗口显示你已有的gist列表，按回车就可以直接去取这个gist并在vim中查看了。</p>

<p>还提供了一些非常有用的配置，比如：</p>

<p>如果你想要在创建了gist后立刻打开浏览器查看：</p>

<p><code>vim
let g:gist_open_browser_after_post = 1
</code></p>

<p>如果想要默认创建的gist不是public而是private：</p>

<p><code>vim
let g:gist_post_private = 1
</code></p>

<p>有了这个插件，玩转gist是不是非常easy啦。这个插件唯一的不足在于在创建gist或者请求gist时会阻塞界面，这个有点糟糕。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--代码搜索ack.vim/ag/ctlsf.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim.html/"/>
    <updated>2014-04-24T19:11:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim</id>
    <content type="html"><![CDATA[<h1 id="ackvim">ack.vim</h1>

<p><a href="https://github.com/petdance/ack">ack.vim</a>。应该是大多数vimer的必装插件。</p>

<p>在写这篇文章的时候才发现ack已经发布了2.0版本，并且ack 1已经不再维护。但是两者差别不大。这里介绍的基于2.0版本。</p>

<p>ack就是一个代码搜索工具，类似grep，用perl编写，充分利用了perl对正则的强大处理能力。为什么用ack而不是直接用grep？ack号称超越了grep。我基本认同。</p>

<ol>
  <li>ack会显示搜索到的行号列号。</li>
  <li>会自动忽略.git这样的文件类型。</li>
  <li>速度很快。</li>
  <li>最重要的是相对grep是一个文本搜索工具，ack就是一个代码搜索工具。你只会搜索到你的js文件，php文件，而不会搜到一些意外的文件类型。</li>
</ol>

<!--more-->

<p>再也不用这样输入：</p>

<pre><code>grep foo $(find . -name '*.pm' | grep -v .svn)
</code></pre>

<p>ack的使用很简单，命令输入：</p>

<pre><code>ack [OPTION]... PATTERN [FILES OR DIRECTORIES]
</code></pre>

<p>如果不输入文件或者文件夹，则默认在当前目录及子目录下搜索。</p>

<p>ack大致有如下几类OPTION，</p>

<ol>
  <li>搜索选项，例如-i, –ignore-case ，忽略pattern的大小写</li>
  <li>搜索结果处理选项，例如 -l，只打印有匹配的文件名。</li>
  <li>搜索输出展现选项，例如–heading，在头部输出匹配文件的文件名</li>
  <li>文件搜索，是的，他还是find。例如 <code>Ack -f servicemodel</code> 查找servicemodel相匹配的文件。</li>
  <li>文件过滤。例如 –[no]ignore-dir=name  从待搜索目录中添加或删除目录。</li>
</ol>

<p>具体的option可以查看ack文档.</p>

<p>这些option都可以直接配置到.ackrc中，作为默认配置。全局的ackrc放置于<code>/etc/ackrc</code>,用户的放在<code>$HOME/.ackrc</code>,仅仅用于某项目的就放在项目根目录中。</p>

<p>ack搜索结果如图所示：</p>

<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efr1w9s9i8j21kw0ghafr.jpg" alt="" /></p>

<p>会打开Quickfix窗口。显示文件名，对于的行列和该行内容。按<code>t</code>可以在新标签打开，按回车直接打开，按v分隔垂直窗口打开等等。和前天介绍的NERD Tree等大多数插件的操作类似。</p>

<h1 id="agvim">ag.vim</h1>

<p>ack的用法就介绍到这里，这里还要介绍的是<a href="https://github.com/ggreer/the_silver_searcher">ag</a>.和ack没什么区别，只是更快。</p>

<p>OS X下安装：</p>

<pre><code>brew install the_silver_searcher
</code></pre>

<p>在vim中进行配置：</p>

<pre><code>let g:ackprg = 'ag --nogroup --nocolor --column'
</code></pre>

<p>也可以直接安装<a href="https://github.com/rking/ag.vim">ag.vim</a>.ack 的 Silver Searcher fork版本。</p>

<h1 id="ctrlsfvim">ctrlsf.vim</h1>

<p>作者原图：</p>

<p><img src="https://camo.githubusercontent.com/fae368edf534ce2228eda41418cb55ee68e19c20/687474703a2f2f692e696d6775722e636f6d2f6d6c576a336d7a2e676966" alt="" /></p>

<p>在安装了ack或者ag的基础上再安装该插件即可。正如它的名字，它提供了和sublime text 2中Ctrl-Shift-F 一样的搜索效果。和ack或者ag不同的是，不再是显示一行，而是显示整个上下文。非常好用。</p>

<p>除此之外，可以按下<code>p</code>进行预览，运行<code>:CtrlSFOpen</code>重新打开搜索结果窗口(默认选择后关闭搜索窗口)。这个插件也是来自国内的朋友。</p>

<p>今天就介绍到这。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--命令行补全cmdline-completion]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion.html/"/>
    <updated>2014-04-23T21:57:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion</id>
    <content type="html"><![CDATA[<p>今天介绍一个非常实用简单的插件，叫做<a href="https://github.com/vim-scripts/cmdline-completion">cmdline-completion</a>.功能就和名字描述的一样，在输入命令的时候，提供补全功能。vim自身对一些命令有补全功能，该插件对其进行了增强。比如：</p>

<ol>
  <li>:something<c-p /></li>
  <li>/else<c-n /></li>
</ol>

<p>也可以自定义快捷键进行补全：</p>

<p><code>vim
 cmap &lt;C-J&gt; &lt;Plug&gt;CmdlineCompletionBackward 
 cmap &lt;C-K&gt; &lt;Plug&gt;CmdlineCompletionForward
</code></p>

<p>今天的介绍非常简短，希望大家喜欢。有问题可以回复给我。</p>
]]></content>
  </entry>
  
</feed>
