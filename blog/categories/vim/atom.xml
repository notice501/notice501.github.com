<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：vim | Code Rush]]></title>
  <link href="http://notice501.github.com/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://notice501.github.com/"/>
  <updated>2014-04-24T22:57:12+08:00</updated>
  <id>http://notice501.github.com/</id>
  <author>
    <name><![CDATA[foocoder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[每日vim插件--代码搜索ack.vim/ag/ctlsf.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim.html/"/>
    <updated>2014-04-24T19:11:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim</id>
    <content type="html"><![CDATA[<h1 id="ackvim">ack.vim</h1>

<p><a href="https://github.com/petdance/ack">ack.vim</a>。应该是大多数vimer的必装插件。</p>

<p>在写这篇文章的时候才发现ack已经发布了2.0版本，并且ack 1已经不再维护。但是两者差别不大。这里介绍的基于2.0版本。</p>

<p>ack就是一个代码搜索工具，类似grep，用perl编写，充分利用了perl对正则的强大处理能力。为什么用ack而不是直接用grep？ack号称超越了grep。我基本认同。</p>

<ol>
  <li>ack会显示搜索到的行号列号。</li>
  <li>会自动忽略.git这样的文件类型。</li>
  <li>速度很快。</li>
  <li>最重要的是相对grep是一个文本搜索工具，ack就是一个代码搜索工具。你只会搜索到你的js文件，php文件，而不会搜到一些意外的文件类型。</li>
</ol>

<!--more-->

<p>再也不用这样输入：</p>

<pre><code>grep foo $(find . -name '*.pm' | grep -v .svn)
</code></pre>

<p>ack的使用很简单，命令输入：</p>

<pre><code>ack [OPTION]... PATTERN [FILES OR DIRECTORIES]
</code></pre>

<p>如果不输入文件或者文件夹，则默认在当前目录及子目录下搜索。</p>

<p>ack大致有如下几类OPTION，</p>

<ol>
  <li>搜索选项，例如-i, –ignore-case ，忽略pattern的大小写</li>
  <li>搜索结果处理选项，例如 -l，只打印有匹配的文件名。</li>
  <li>搜索输出展现选项，例如–heading，在头部输出匹配文件的文件名</li>
  <li>文件搜索，是的，他还是find。例如 <code>Ack -f servicemodel</code> 查找servicemodel相匹配的文件。</li>
  <li>文件过滤。例如 –[no]ignore-dir=name  从待搜索目录中添加或删除目录。</li>
</ol>

<p>具体的option可以查看ack文档.</p>

<p>这些option都可以直接配置到.ackrc中，作为默认配置。全局的ackrc放置于<code>/etc/ackrc</code>,用户的放在<code>$HOME/.ackrc</code>,仅仅用于某项目的就放在项目根目录中。</p>

<p>ack搜索结果如图所示：</p>

<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efr1w9s9i8j21kw0ghafr.jpg" alt="" /></p>

<p>会打开Quickfix窗口。显示文件名，对于的行列和该行内容。按<code>t</code>可以在新标签打开，按回车直接打开，按v分隔垂直窗口打开等等。和前天介绍的NERD Tree等大多数插件的操作类似。</p>

<h1 id="agvim">ag.vim</h1>

<p>ack的用法就介绍到这里，这里还要介绍的是<a href="https://github.com/ggreer/the_silver_searcher">ag</a>.和ack没什么区别，只是更快。</p>

<p>OS X下安装：</p>

<pre><code>brew install the_silver_searcher
</code></pre>

<p>在vim中进行配置：</p>

<pre><code>let g:ackprg = 'ag --nogroup --nocolor --column'
</code></pre>

<p>也可以直接安装<a href="https://github.com/rking/ag.vim">ag.vim</a>.ack 的 Silver Searcher fork版本。</p>

<h1 id="ctrlsfvim">ctrlsf.vim</h1>

<p>作者原图：</p>

<p><img src="https://camo.githubusercontent.com/fae368edf534ce2228eda41418cb55ee68e19c20/687474703a2f2f692e696d6775722e636f6d2f6d6c576a336d7a2e676966" alt="" /></p>

<p>在安装了ack或者ag的基础上再安装该插件即可。正如它的名字，它提供了和sublime text 2中Ctrl-Shift-F 一样的搜索效果。和ack或者ag不同的是，不再是显示一行，而是显示整个上下文。非常好用。</p>

<p>除此之外，可以按下<code>p</code>进行预览，运行<code>:CtrlSFOpen</code>重新打开搜索结果窗口(默认选择后关闭搜索窗口)。这个插件也是来自国内的朋友。</p>

<p>今天就介绍到这。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--命令行补全cmdline-completion]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion.html/"/>
    <updated>2014-04-23T21:57:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion</id>
    <content type="html"><![CDATA[<p>今天介绍一个非常实用简单的插件，叫做<a href="https://github.com/vim-scripts/cmdline-completion">cmdline-completion</a>.功能就和名字描述的一样，在输入命令的时候，提供补全功能。vim自身对一些命令有补全功能，该插件对其进行了增强。比如：</p>

<ol>
  <li>:something<c-p /></li>
  <li>/else<c-n /></li>
</ol>

<p>也可以自定义快捷键进行补全：</p>

<p><code>vim
 cmap &lt;C-J&gt; &lt;Plug&gt;CmdlineCompletionBackward 
 cmap &lt;C-K&gt; &lt;Plug&gt;CmdlineCompletionForward
</code></p>

<p>今天的介绍非常简短，希望大家喜欢。有问题可以回复给我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--文件浏览器NERD Tree以及git-nerdtree,vim-nerdtree-tabs]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs.html/"/>
    <updated>2014-04-22T19:43:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs</id>
    <content type="html"><![CDATA[<p>今天介绍一个必备插件——<a href="https://github.com/scrooloose/nerdtree">NERD Tree</a>。这个插件基本用vim的都会知道吧。看图就知道了：
<img src="http://ww2.sinaimg.cn/large/69d56e38gw1efoqvqpramj21gu12i46s.jpg" alt="" /></p>

<p>用它可以让vim像其他大多数编辑器或者IDE一样，打开一个分割窗口显示文件树，在这个文件树上可以通过<code>j</code>,<code>k</code>上下浏览以及其他一些快捷键进行快速文件导航。按回车就直接打开该文件，当然还可以通过<code>i</code>,<code>s</code>,<code>t</code>在分隔窗口或者在新标签页打开.</p>

<!--more-->

<p>NERD Tree还支持书签。所谓书签，就是标记该文件或文件夹会优先显示在最上方。如前面图中的_posts文件夹。只要光标在该文件上输入命令<code>:Bookmark &lt;name&gt;</code>.非常方便</p>

<p>NERD Tree不想介绍过多，使用非常简单。在NerdTree窗口按下问号就会有帮助信息介绍所有的操作和对应的快捷键，常用下很快就很熟了。</p>

<p>NERD Tree有个问题在于和大多数IDE或者编辑器不同的是，在新的Tab中，NERD Tree默认是不打开的。不同的tab不能共享一个NERD Tree窗口，有人对这种方式可能就比较别扭。这时候就诞生了<a href="https://github.com/jistr/vim-nerdtree-tabs">vim-nerdtree-tabs</a>.该插件就解决了这个问题，它让每个tab都有相同的NERD Tree，看起来就像NERD Tree固定在最左一样。按下<code>:NERDTreeTabsToggle</code>就可以打开或关闭所有窗口。关闭文件窗口的时候，对于tab的NERD Tree窗口也会自动关闭。</p>

<p>接下来介绍的<a href="https://github.com/Xuyuanp/git-nerdtree">git-nerdtree</a>是来自@Xuyuanp的作品,通过微信公众号介绍给我。也是对NERD Tree的增强修改，增加了文件的git状态显示，和昨天的gitgutter类似，Gitgutter显示文件内的git diff，而git-nerdtree为NERD Tree增加了文件git状态的显示：</p>

<p><img src="https://camo.githubusercontent.com/3fe0388df11cb787f36e1fa108398fd3f757eef4/687474703a2f2f692e696d6775722e636f6d2f6a534377476a552e6769663f31" alt="" /></p>

<p>相对应的标识如下：</p>

<ul>
  <li><code>✭</code> / <code>*</code> : Untracked</li>
  <li><code>✹</code> / <code>~</code> : Modified in the working tree</li>
  <li><code>✚</code> / <code>+</code> : Staged in the index (Exclude Renamed status)</li>
  <li><code>➜</code> / <code>»</code> : Renamed</li>
  <li><code>═</code> / <code>=</code> : Unmerged</li>
  <li><code>✖</code> / <code>-</code> : Deleted (This indicator can’t be shown, as NERDTree doesn’t display deleted files. I have no prefect idea to solve this problem currently.)</li>
  <li><code>✗</code> / <code>×</code> : Dirty (Only for directory)</li>
  <li><code>✔</code> / <code>ø</code> : Clean (Only for directory)</li>
</ul>

<p>标识方式和我之前介绍的zsh配置对git库状态的处理类似（可以查看我之前的博客）。</p>

<p>同时还支持和gitgutter一样的快捷键在各个有状态的文件之间跳转<code>[c</code>,<code>]c</code>.我只能说太棒了，再次感谢@Xuyuanp。</p>

<p>今天就介绍到这里，任何问题都可以直接回复。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--快速选择文本对象wildfile.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim.html/"/>
    <updated>2014-04-18T20:06:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim</id>
    <content type="html"><![CDATA[<p>之前我们介绍了文本对象，并介绍了两个自定义文本对象的插件。今天介绍的插件也和文本对象有关。他可以用来快速的就近选择一个候选文本对象，并能通过快捷键继续简单的扩大文本对象范围。</p>

<p>这个插件就是–<a href="https://github.com/Shougo/wildfire.vim">wildfire</a>（给的是shougo fork的repo地址，比较喜欢shougo这个插件作者，而且这个fork fix了一个bug）</p>

<p>插件默认定义的候选文本对象为：</p>

<pre><code> `i'`, `i"`, `i)`, `i]`, `i}`, `ip` and `it`
</code></pre>

<p>来一张官方图</p>

<!--more-->

<p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efk07xfk7kg20jv087myy.gif" alt="" /></p>

<p>有图应该大家能理解这个插件的作用了。</p>

<p>使用方式也非常简单，按<code>enter</code>选择最近一个文本对象，再按下<code>enter</code>在刚刚的选择之上再选择最近的文本对象。按下<code>&lt;BS&gt;</code>就能回退到上一个选择。</p>

<p>当然，你可以自定义快捷键：</p>

<p>```vim
“ This selects the next closest text object.
let g:wildfire_fuel_map = “<enter>"</enter></p>

<p>” This selects the previous closest text object.
let g:wildfire_water_map = “<bs>"
```</bs></p>

<p>候选的文本对象也是可以配置的：</p>

<p><code>vim
let g:wildfire_objects = ["i'", 'i"', "i)", "i]", "i}", "ip", "it"]
</code></p>

<p>插件还支持对文件类型分别定义，比如要在html中只处理tag，忽略其他文本对象，只需要配置：</p>

<p><code>vim
" use '*' to mean 'all other filetypes'
" in this example, html and xml share the same text objects
let g:wildfire_objects = {
    \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
    \ "html,xml" : ["at"],
\ }
</code></p>

<p>与之类似的一个用的相当广泛的插件还有<a href="https://github.com/terryma/vim-expand-region">vim-expand-region</a>。大家可以自己选择。有问题欢迎留言或回复交流。也希望大家推荐自己在用，自己写的插件给我。今天看到一个朋友微信回复我的一个他自己写的插件，我已经立刻用上了，卖个关子，下次介绍。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--可以重复motion的space.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim.html/"/>
    <updated>2014-04-17T21:10:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim</id>
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efiwusn0uhj20m80godg5.jpg" style="height: 400px;" /></p>

<p>今天头疼的厉害。不过昨天没更新，今天必须有了。介绍个简单点的。</p>

<p>vim中在普通模式下，空格这么大一按键不用有点浪费，所以有了<a href="https://github.com/spiiph/vim-space">space.vim</a>.</p>

<!--more-->

<p>他能重复执行motion，比如</p>

<pre><code>*Hello World
</code></pre>

<p>按下<code>fo</code>,会将光标移动到第一个o上，再按下空格，就能移动到第二个o了，他会重复执行上一个<code>fo</code>。按下<code>&lt;Shift-Space&gt;</code>反向执行改操作，也就是光标又会回到第一个<code>o</code>.</p>

<p>除此之外，space.vim还能重复搜索命令，diff移动命令，qucikfix等操作。让空格键变的非常有用.下面是space.vim可以重复的全部命令列表：</p>

<p>```
Character movements:                                    |left-right-motions|
    |f| |F| |t| |T| |;| |,|</p>

<table>
  <tbody>
    <tr>
      <td>Search commands:</td>
      <td>search-commands</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>star</td>
      <td> </td>
      <td>gstar</td>
      <td> </td>
      <td>#</td>
      <td> </td>
      <td>g#</td>
      <td> </td>
      <td>n</td>
      <td> </td>
      <td>N</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Jump list jumps:</td>
      <td>jump-motions</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-O</td>
      <td> </td>
      <td>CTRL-I</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Change list jumps:</td>
      <td>change-list-jumps</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g;</td>
      <td> </td>
      <td>g,</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Diff jumps:</td>
      <td>jumpto-diffs</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]c</td>
      <td> </td>
      <td>[c</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Parenthesis and bracket jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>])</td>
      <td> </td>
      <td>[(</td>
      <td> </td>
      <td>]}</td>
      <td> </td>
      <td>[{</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Method jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]m</td>
      <td> </td>
      <td>[m</td>
      <td> </td>
      <td>]M</td>
      <td> </td>
      <td>[M</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Section jumps:</td>
      <td>object-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]]</td>
      <td> </td>
      <td>[]</td>
      <td> </td>
      <td>][</td>
      <td> </td>
      <td>[[</td>
    </tr>
  </tbody>
</table>

<p>Fold movements:
    |zj| |zk| |]z| |[z|</p>

<table>
  <tbody>
    <tr>
      <td>Tag movements:</td>
      <td>tag-commands</td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-]</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tag</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:trewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tlast</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Undolist movements:</td>
      <td>undo-branches</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g-</td>
      <td> </td>
      <td>g+</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Quickfix commands:</td>
      <td>quickfix</td>
    </tr>
    <tr>
      <td> </td>
      <td>:make</td>
    </tr>
    <tr>
      <td> </td>
      <td>:vimgrep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:grep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cc</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:clast</td>
    </tr>
    <tr>
      <td> </td>
      <td>:crewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cpfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNfile</td>
    </tr>
  </tbody>
</table>

<p>Location list commands:                                      |location-list|
    |:lmake|
    |:lvimgrep|
    |:lgrep|
    |:ll|
    |:lcnext|
    |:lcprevious|
    |:lcNext|
    |:lcfirst|
    |:lclast|
    |:lcrewind|
    |:lcfile|
    |:lcnfile|
    |:lcpfile|
    |:lcNfile|
```</p>

<p>今天解介绍到这里。</p>
]]></content>
  </entry>
  
</feed>
