<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：vim | Code Rush]]></title>
  <link href="http://notice501.github.com/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://notice501.github.com/"/>
  <updated>2014-04-18T16:36:44+08:00</updated>
  <id>http://notice501.github.com/</id>
  <author>
    <name><![CDATA[foocoder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[每日vim插件--可以重复motion的space.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim.html/"/>
    <updated>2014-04-17T21:10:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim</id>
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efiwusn0uhj20m80godg5.jpg" style="height: 400px;" /></p>

<p>今天头疼的厉害。不过昨天没更新，今天必须有了。介绍个简单点的。</p>

<p>vim中在普通模式下，空格这么大一按键不用有点浪费，所以有了<a href="https://github.com/spiiph/vim-space">space.vim</a>.</p>

<!--more-->

<p>他能重复执行motion，比如</p>

<pre><code>*Hello World
</code></pre>

<p>按下<code>fo</code>,会将光标移动到第一个o上，再按下空格，就能移动到第二个o了，他会重复执行上一个<code>fo</code>。按下<code>&lt;Shift-Space&gt;</code>反向执行改操作，也就是光标又会回到第一个<code>o</code>.</p>

<p>除此之外，space.vim还能重复搜索命令，diff移动命令，qucikfix等操作。让空格键变的非常有用.下面是space.vim可以重复的全部命令列表：</p>

<p>```
Character movements:                                    |left-right-motions|
    |f| |F| |t| |T| |;| |,|</p>

<table>
  <tbody>
    <tr>
      <td>Search commands:</td>
      <td>search-commands</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>star</td>
      <td> </td>
      <td>gstar</td>
      <td> </td>
      <td>#</td>
      <td> </td>
      <td>g#</td>
      <td> </td>
      <td>n</td>
      <td> </td>
      <td>N</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Jump list jumps:</td>
      <td>jump-motions</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-O</td>
      <td> </td>
      <td>CTRL-I</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Change list jumps:</td>
      <td>change-list-jumps</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g;</td>
      <td> </td>
      <td>g,</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Diff jumps:</td>
      <td>jumpto-diffs</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]c</td>
      <td> </td>
      <td>[c</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Parenthesis and bracket jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>])</td>
      <td> </td>
      <td>[(</td>
      <td> </td>
      <td>]}</td>
      <td> </td>
      <td>[{</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Method jumps:</td>
      <td>various-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]m</td>
      <td> </td>
      <td>[m</td>
      <td> </td>
      <td>]M</td>
      <td> </td>
      <td>[M</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Section jumps:</td>
      <td>object-motions</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>]]</td>
      <td> </td>
      <td>[]</td>
      <td> </td>
      <td>][</td>
      <td> </td>
      <td>[[</td>
    </tr>
  </tbody>
</table>

<p>Fold movements:
    |zj| |zk| |]z| |[z|</p>

<table>
  <tbody>
    <tr>
      <td>Tag movements:</td>
      <td>tag-commands</td>
    </tr>
    <tr>
      <td> </td>
      <td>CTRL-]</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tag</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:trewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:tlast</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Undolist movements:</td>
      <td>undo-branches</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>g-</td>
      <td> </td>
      <td>g+</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Quickfix commands:</td>
      <td>quickfix</td>
    </tr>
    <tr>
      <td> </td>
      <td>:make</td>
    </tr>
    <tr>
      <td> </td>
      <td>:vimgrep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:grep</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cc</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cprevious</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNext</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfirst</td>
    </tr>
    <tr>
      <td> </td>
      <td>:clast</td>
    </tr>
    <tr>
      <td> </td>
      <td>:crewind</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cnfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cpfile</td>
    </tr>
    <tr>
      <td> </td>
      <td>:cNfile</td>
    </tr>
  </tbody>
</table>

<p>Location list commands:                                      |location-list|
    |:lmake|
    |:lvimgrep|
    |:lgrep|
    |:ll|
    |:lcnext|
    |:lcprevious|
    |:lcNext|
    |:lcfirst|
    |:lclast|
    |:lcrewind|
    |:lcfile|
    |:lcnfile|
    |:lcpfile|
    |:lcNfile|
```</p>

<p>今天解介绍到这里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--vim 撤销树Gundo.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim.html/"/>
    <updated>2014-04-15T21:10:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim</id>
    <content type="html"><![CDATA[<p>今天介绍的插件很有意思，也非常有用，也是我最常用的插件之一——<a href="https://github.com/sjl/gundo.vim">Gundo</a>.</p>

<p>大家都知道按<code>u</code>可以撤销操作，但是一般都不知道输入命令<code>:undolist</code>会显示可撤销列表，如图</p>

<p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efglaef02lj20ki13qthg.jpg" style="     height: 600px; " /> </p>

<p>其实这还不是列表，而是整个vim 撤销树的叶子。为什么说是树，而不是列表，举个例子就明白了：</p>

<!--more-->

<p>你在a状态做了一次修改到b，又回退到a，再做了一次修改到c。大多数编辑器比如sublime text，b这个状态就没了，但是vim会用一个树进行保存。</p>

<p>而Gundo这个插件就是一个撤销树浏览器.直接上张图：</p>

<p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efgmev2lz4j20ok1ci78i.jpg" style="     height: 600px; " /></p>

<p>当前位置以<code>@</code>标注，其他历史以o标注。</p>

<p>按jk上下移动，就可以在下面的窗口看到对应修改之前的改动。这个就是普通的vim窗口，所有的移动操作都是支持的，比如<code>G</code>到底部，<code>C-U</code>上翻页等。</p>

<p>按<code>p</code>可以查看选中状态和当前状态的差异，按回车就会回到选中状态，按<code>P</code>更是可以一步步播放到选中状态，高上大啊……</p>

<p>btw,我习惯将所有的undo记录都保存下来，即使关闭了vim或者buffer也能继续撤销。</p>

<p>只需要稍加配置，就能将撤销树持久化存储下来：</p>

<p><code>vim
try
    set undodir=~/.vim/temp_dirs/undodir
    set undofile
catch
endtry
</code></p>

<p>今天就介绍到这里。有问题直接回复给我。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--vim中的文本对象及相关插件]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian.html/"/>
    <updated>2014-04-14T22:56:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian</id>
    <content type="html"><![CDATA[<p>今天按读者留言的要求，介绍下文本对象。同时还会介绍我在用的几个文本相关的插件，今天是满满的内容啊。</p>

<p>所谓文本对象，简单来说就是以一定标准分隔符来标识一段文本，比如一个单词，一句话，一段话。</p>

<p>使用文本对象后你会发现你在vim中的移动和操作速度提升了不是一点半点。</p>

<p>在vim中编辑命令的结构如下：</p>

<pre><code> &lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;
</code></pre>

<p>可以看到文本对象和motion的操作是完全一致的，第一个是数字，比如3w，就向前移动三个单词。</p>

<!--more-->

<p>文本对象大致有以下几种：</p>

<pre><code>w  s  p '' ""  &lt;&gt;  []  ()  {} &lt;tag&gt;
</code></pre>

<p>其中w表示word，s表示句子，p表示段落，其他的就是昨天介绍过的包围符号，标签用t表示。</p>

<p>文本对象的操作范围有两种，一种用<code>i</code>表示,是inner的意思，即不包括单词边上的空格符，亦或是<code>&lt;</code>包围符号本身。一种用<code>a</code>表示，是arround的意思，和i相反，使用a就包括了空格符或者包围符号本身。</p>

<p>文本对象的编辑命令就是vim中的几个常用编辑命令，分别是</p>

<pre><code>`y：复制`，`d：删除`,`c：替换`，`v：选中`
</code></pre>

<p>说的有点多了，来几个例子相信大家就立刻理解了。（例子中*都是光标所在位置）</p>

<p>比如：</p>

<pre><code>&lt;*h2&gt;Sample Title&lt;/h2&gt;
</code></pre>

<p>按下<code>cit</code>,文本变为：</p>

<pre><code>&lt;h2&gt;*&lt;/h2&gt;
</code></pre>

<p>再比如：
	console.log(“stay hungry,” + “stay *foolish”)</p>

<p>按下<code>da"</code>，文本变为：</p>

<pre><code>console.log("stay hungry," +*)
</code></pre>

<p>再按下<code>di)</code>，文本变为：</p>

<pre><code>console.log()
</code></pre>

<p>比如</p>

<pre><code>Hello Worl*d
</code></pre>

<p>按下<code>diw</code>,文本变为：</p>

<pre><code>Hello
</code></pre>

<p>很容易理解是不是？有没有发现为什么说文本对象会非常方便了？无论光标在文本的哪个位置，都可以直接操作整个文本。体验箭步如飞的感觉吧。</p>

<p>vim还允许使用脚本来自定义文本对象，这就是我们今天要介绍的插件了，这些插件自定义了一些文本对象。</p>

<p>1.CamelCaseMotion</p>

<p>该插件是把驼峰词语的每个单词分开，举个例子：</p>

<pre><code>get*ElementsByClassName
</code></pre>

<p>按下<code>di,w</code>,则文本变为：</p>

<pre><code>getByClassName
</code></pre>

<p>非常方便。</p>

<p>2.argtextobj</p>

<p>该插件定义了函数内的参数文本对象。比如：</p>

<pre><code>foo(text, ti*mes, option) {}
</code></pre>

<p>按下<code>daa</code>,则文本变为：</p>

<pre><code>foo(text, option) {}
</code></pre>

<p>今天暂时就介绍到这里。都快0点了，赶紧发出来。任何问题都可以回复给我。	</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--surround.vim]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-surround-dot-vim.html/"/>
    <updated>2014-04-13T22:11:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-surround-dot-vim</id>
    <content type="html"><![CDATA[<p>今天介绍一个必备的插件——<a href="https://github.com/tpope/vim-surround">surround.vim</a>,来自Tim Pope大神，很多著名的插件包括pathogen.vim都是出自他手，后面我还会介绍更多他写的插件。</p>

<p>是我最常用的插件之一。这个插件专门用来处理成对的包围符号……比如说括号，单双引号，XML标签等。</p>

<p>使用也非常简单好记，遵循vim本身的规则。</p>

<p>先来看一组实例，就知道这个插件的用途和使用方式了：</p>

<p>光标在</p>

<pre><code>"Hello world!"
</code></pre>

<p>中时按下<code>cs"'</code> ，则会替换双引号为单引号：</p>

<pre><code>'Hello world!'
</code></pre>

<!--more-->

<p>继续按下<code>cs'&lt;q&gt;</code>，则会替换单引号为<q>标签</q></p>

<pre><code>&lt;q&gt;Hello world!&lt;/q&gt;
</code></pre>

<p>按下 <code>cst"</code>，则回到初始的双引号：</p>

<pre><code> "Hello world!"
</code></pre>

<p>要删除符号，则按下<code>ds"</code></p>

<pre><code>Hello world!
</code></pre>

<p>当光标在hello上时，按下<code>ysiw]</code>，则会变为</p>

<pre><code> [Hello] world!
</code></pre>

<p>这个操作为其加上了包围符号。</p>

<p>总结下：</p>

<p>1.删除包围符号的命令是<code>ds</code>,后面加的字符表示要删除的符号。比如：</p>

<pre><code>"Hello *world!"           ds"         Hello world!
</code></pre>

<p>2.替换包围符号的命令是<code>cs</code>,命令后跟两个参数，分别是被替换的符号和需要使用的符号。比如</p>

<pre><code>"Hello *world!"           cs"'        'Hello world!'
</code></pre>

<p>3.添加包围符号的命令是<code>ys</code>(ys可以记为you surround)，命令后同样跟两个参数，第一个是一个vim“动作”（motion）或者是一个文本对象。</p>

<p>其中motion即vim动作，比如说<code>w</code>向后一个单词。文本对象简单的来说主要是来通过一些分隔符来标识一段文本，比如<code>iw</code>就是一个文本对象，即光标下的单词。不理解的朋友可以将光标放置在单词hello的中央，分别试一下<code>ysw</code>和<code>ysiw</code>的区别应该就明白啦。如果大家需要详细介绍motion和文本对象，可以留言或者直接公众账号回复，我看看要不要单独介绍下。</p>

<pre><code>  Hello w*orld!             ysiw)       Hello (world)!
</code></pre>

<p>另外：<code>yss</code>命令可以用于整行操作，忽略中间的空格。
<code>yS</code>和<code>ySS</code>还能让包围内容单独一行并且加上缩进。</p>

<p>4.添加包围符号还有个非常好用的方式：在可视模式v下，按下<code>S</code>后即可添加想要添加的包围符号了。</p>

<p>再说一个小技巧：在包围符号为括时，输入左括号<code>(或者{</code>,则会留一个空格</p>

<pre><code>Hello w*orld!             ysiw(       Hello ( world )!
</code></pre>

<p>而右括号则不留空格，也是非常好用，看编码风格使用。</p>

<p>今天就介绍到这里，欢迎关注我的公众账号，最新的文章都会第一时间推送到。有问题可以直接回复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每日vim插件--缩进显示vim-indent-guides]]></title>
    <link href="http://notice501.github.com/blog/mei-ri-vimcha-jian-suo-jin-xian-shi-vim-indent-guides.html/"/>
    <updated>2014-04-11T17:49:00+08:00</updated>
    <id>http://notice501.github.com/blog/mei-ri-vimcha-jian-suo-jin-xian-shi-vim-indent-guides</id>
    <content type="html"><![CDATA[<p>今天有朋友留言问昨天晒配色的图中缩进用的什么插件，那今天就介绍这个缩进插件——<a href="https://github.com/nathanaelkane/vim-indent-guides">vim-indent-guides</a></p>

<p>选择这个插件主要有几个理由：</p>

<ol>
  <li>插件对tab和空格的支持都很好。</li>
  <li>比较美观。</li>
  <li>能够自动适配当前使用的colorscheme来选择缩进颜色（只能是gvim，macvim下适配的不错）</li>
</ol>

<!--more-->
<p>默认的快捷键是<code>&lt;Leader&gt;ig</code>,开关插件。我一般都默认启动就开启,只要设置：</p>

<p><code>vim
let g:indent_guides_enable_on_vim_startup = 1
</code></p>

<p>前面说了缩进的颜色是自动选择的，非常方便，但是想要自定义颜色也是支持的：</p>

<p><code>vim
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=3
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=4
</code></p>

<p>在终端中该插件就不支持颜色自动选择了。只取决于<code>background</code>设置为<code>dark</code>还是<code>light</code>,如果设置了<code>dark</code>,就相当于配置了</p>

<p><code>vim
hi IndentGuidesOdd  ctermbg=black
hi IndentGuidesEven ctermbg=darkgrey
</code>
来几张图，图上标注了相应的配置：</p>

<p><img src="http://ww4.sinaimg.cn/large/69d56e38gw1efbth8m9aij20cg0cgta5.jpg" alt="" />
<img src="http://ww2.sinaimg.cn/large/69d56e38gw1efbtngrerjj20cg0cg3zt.jpg" alt="" />
<img src="http://ww2.sinaimg.cn/large/69d56e38gw1efbtqa6k47j20cg0cgjsq.jpg" alt="" /></p>

<p>这个插件并不能很好的标记出tab和空格混用的情况，只能显示当前缩进。所以我在我的vimrc中加了一行：
<code>
" highlight tabs and trailing spaces
set list
set listchars=tab:&gt;-,trail:-,extends:&gt;,precedes:&lt;
</code>
这样tab会被显示为&gt;-，而尾部空格被显示为-，这样写出来的代码就不会再有杂乱符号啦。</p>

<p>今天就介绍到这里。我开通了一个微信公众账号，以后每天的文章会通过微信公众账号推送，欢迎关注。</p>
]]></content>
  </entry>
  
</feed>
