<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Rush</title>
  <icon>https://www.gravatar.com/avatar/c8d3ee2c26095aa48bb648cd7d083dca</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foocoder.com/"/>
  <updated>2017-11-06T12:52:46.000Z</updated>
  <id>http://foocoder.com/</id>
  
  <author>
    <name>foocoder</name>
    <email>notice520@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次orm库性能优化，谈谈android的注解处理和代码生成</title>
    <link href="http://foocoder.com/2017/11/06/%E8%AE%B0%E4%B8%80%E6%AC%A1orm%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E8%B0%88%E8%B0%88android%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <id>http://foocoder.com/2017/11/06/记一次orm库性能优化，谈谈android的注解处理和代码生成/</id>
    <published>2017-11-06T12:51:23.000Z</published>
    <updated>2017-11-06T12:52:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早的时候因为业务的需要，找不到一款合适的orm框架，当时自己写了一个。很长时间过去了，一直想对这个orm库做一次性能优化，换掉原有的反射的注解处理方式，而是通过代码生成，从而大幅提高性能。</p><p>原有的orm库通过反射的注解处理方式来实现。原有的Table注解声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line">    <span class="meta">@interface</span> Column &#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnionKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">      </div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里简单介绍下注解的知识。通过关键字@interface来定义注解，这里定一个了一个名为Table的注解，Table声明本身上面也有两个注解，这个叫做元注解，一共有四种元注解，分别为：</p><ul><li><code>@Retention</code> 注解的有效范围<ul><li><code>SOURCE</code>，只在源码中可用，一般用来增加代码理解和代码检查等，常见的如Override</li><li><code>CLASS</code>, 默认选项，在源码和字节码中可用，但仅存于字节码文件中，运行时无法获取</li><li><code>RUNTIME</code>, 在源码,字节码,运行时均可用</li></ul></li><li><code>@Target</code> 指定注解修饰的程序元素，如 <code>TYPE</code>, <code>METHOD</code>, <code>CONSTRUCTOR</code>, <code>FIELD</code>, <code>PARAMETER</code>等，未标注则表示可修饰所有</li><li><code>@Inherited</code> 是否可以被继承，默认为false</li><li><code>@Documented</code> 是否会保存到 Javadoc 文档中</li></ul><p>回到上述的表注解定义，可以看到定义了一个Target为TYPE的Table类注解和一个Type为FIELD的Column成员变量注解。</p><p>完成以后，我们就可以如下来定一个对象的同时创建一张表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Table</span>(name = User.TABLE_NAME)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Table</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"user"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUME_ID = <span class="string">"id"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUME_NAME = <span class="string">"name"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUME_AGE = <span class="string">"age"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUME_MALE = <span class="string">"male"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Table</span>.Column(name = COLUME_ID, isPrimaryKey = <span class="keyword">true</span>)</div><div class="line">    String id;</div><div class="line"></div><div class="line">    <span class="meta">@Table</span>.Column(name = COLUME_NAME, defaultValue = <span class="string">"unknown"</span>)</div><div class="line">    String name;</div><div class="line"></div><div class="line">    <span class="meta">@Table</span>.Column(name = COLUME_AGE)</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="meta">@Table</span>.Column(name = COLUME_MALE)</div><div class="line">    <span class="keyword">boolean</span> isMale;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个简单的User对象，有id，name，age，isMale四个成员变量，通过注解声明表名为有四个colunm的’user’表。</p><p>使用orm库让插入和建表一样简单，不用写sql操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">User user = <span class="keyword">new</span> User();</div><div class="line">user.id = <span class="number">0</span>;</div><div class="line">user.name = <span class="string">"Tom"</span>;</div><div class="line">user.age =<span class="number">10</span>;</div><div class="line">user.save();</div></pre></td></tr></table></figure><p>上面代码定义了一个User对象，并调用了User对象的save方法，save()方法来自父类Table类。这里说下整个建表和插入一个user数据的核心逻辑。</p><p>首先建表过程，关于获取列信息的部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Field[] fields = columnType.getDeclaredFields();</div><div class="line"><span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line"><span class="keyword">if</span> (field.isAnnotationPresent(Column.class)) &#123;                  </div><div class="line">    Column annotationColumn = field.getAnnotation(Column.class);</div><div class="line">        <span class="keyword">if</span> (annotationColumn == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String columnName = columnAnnotation.name();</div><div class="line">        String isPrimaryKey = columnAnnotation.isPrimaryKey();</div><div class="line">        .........</div><div class="line">        Class&lt;?&gt; type = field.getType();</div><div class="line">        SQLiteType columnType = JavaToSQLiteType.getJavaSQLiteType(type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了控制篇幅，不讲具体orm实现，只贴出部分核心代码。首先通过反射获取User里所有的fields，判断field是否有Column注解，有则获取注解上的column信息，包括每个column的columnName，isPrimaryKey等。拿到了每一个列的具体信息，再完成java类型到sqlite类型的转换，表的列信息就全部获取到了。最后将其生成sql代码并执行，这样一张表就建好了。</p><p>插入操作也是通过反射来完成，通过反射获取user对象的所有field的值，再通过之前建表时就获取的表名，列名就可以用sql语句完成数据的插入。</p><p>可以看到整个orm的核心逻辑都是通过反射来实现的，包括表的创建以及增删改查。这也是这个库1.x版本的性能瓶颈，实测下来插入查询都会比一些流行库慢很多。所以这次优化的核心点就是去反射。也就是要替换原有通过反射来获取用户声明的表结构的部分。实现的方法就是接下来要讲的通过编译时注解进行代码生成，完成表结构获取，增删改查的代码生成。从而去掉大量反射逻辑，大幅提高性能。</p><p>首先改变注解定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line">    <span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line">    <span class="meta">@interface</span> Column &#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnionKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">      </div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意唯一改变的就是@Retention注解，从原有的<code>RetentionPolicy.RUNTIME</code>改成<code>@Retention(RetentionPolicy.CLASS)</code>。前面已经提到，也就是从运行时注解改为编译时注解，从而在编译时通过注解处理生成代码，完成表信息，增删改查接口的代码生成。</p><p>还是说建表和插入操作。建表只需要获取声明的表信息，所以应该提供一个方法来获取表的所有列信息，而插入方法很直白，就是要用于数据插入。那代码生成需要一个initColumnInfoList方法和一个save方法。来看实现。</p><p>注解的处理只需继承AbstractProcessor类，主要实现process方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="meta">@SupportedOptions</span>(&#123;OrmProcessor.TARGET_MODULE_NAME&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrmProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    ........</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">        handleTableAnnotation(roundEnv);</div><div class="line">....</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理 <span class="doctag">@Table</span> 注解</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnv</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleTableAnnotation</span><span class="params">(RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line">        Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Table.class);</div><div class="line">        <span class="keyword">for</span> (Element element : set) &#123;</div><div class="line">            <span class="keyword">if</span> (isValid(element)) &#123;</div><div class="line">                TypeElement typeElement = (TypeElement) element;</div><div class="line">                PackageElement packageElement = (PackageElement) element.getEnclosingElement();</div><div class="line"></div><div class="line">                Map&lt;Table.Column, VariableInfo&gt; columnMap = <span class="keyword">new</span> TreeMap&lt;&gt;(AdapterGenerator.sTableColumnComparator);</div><div class="line"></div><div class="line">                List&lt;VariableElement&gt; variableElementList = ElementFilter.fieldsIn(typeElement.getEnclosedElements());</div><div class="line">                <span class="keyword">for</span> (VariableElement ve : variableElementList) &#123;</div><div class="line">                    Table.Column column = ve.getAnnotation(Table.Column.class);</div><div class="line">                    <span class="keyword">if</span> (column == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    String variableName = ve.getSimpleName().toString();</div><div class="line"></div><div class="line">                    <span class="comment">// 获取属性类型</span></div><div class="line">                    TypeMirror typeMirror = ve.asType();</div><div class="line"></div><div class="line">                    columnMap.put(column, <span class="keyword">new</span> VariableInfo(variableName, typeMirror));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                String fullName = typeElement.getQualifiedName().toString();</div><div class="line">                String className = typeElement.getSimpleName().toString();</div><div class="line">                String packageName = packageElement.getQualifiedName().toString();</div><div class="line"></div><div class="line">                ClassInfo classInfo = <span class="keyword">new</span> ClassInfo(fullName, className, packageName);</div><div class="line"></div><div class="line">                Table table = typeElement.getAnnotation(Table.class);</div><div class="line">                String tableName = table.name();</div><div class="line"></div><div class="line">                AdapterGenerator.generateTableAdapter(processingEnv.getFiler(), classInfo, tableName, columnMap);</div><div class="line"></div><div class="line">                tableMap.put(fullName, ADAPTER_PACKAGE + <span class="string">"."</span> + className + TABLE_ADAPTER_POSTFIX);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  ....... </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过参数roundEnv拿到User表注解中的所有信息，包括表名,列名以及类型。其中<code>AdapterGenerator.generateTableAdapter</code>方法将获取到的表信息生成java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateTableAdapter</span><span class="params">(Filer filer, ClassInfo classInfo, String tableName,</span></span></div><div class="line"><span class="function"><span class="params">                                           Map&lt;Table.Column, VariableInfo&gt; columnMap)</span> </span>&#123;</div><div class="line"></div><div class="line">   </div><div class="line">      .....</div><div class="line"></div><div class="line">       <span class="comment">// initColumnInfoList方法</span></div><div class="line">       MethodSpec.Builder initListBuilder = MethodSpec.methodBuilder(<span class="string">"initColumnInfoList"</span>)</div><div class="line">               .addAnnotation(Override.class)</div><div class="line">               .addModifiers(Modifier.PROTECTED)</div><div class="line">               .addStatement(<span class="string">"columnInfoList = new $T()"</span>, arrayListClassName);</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Table.Column, VariableInfo&gt; entry : columnMap.entrySet()) &#123;</div><div class="line">           Table.Column column = entry.getKey();</div><div class="line">           VariableInfo variableInfo = entry.getValue();</div><div class="line"></div><div class="line">           initListBuilder.addStatement(<span class="string">"$T info_$L = new $T($L, $S, $L, $S, $L, $L, $L, $L, $S, $L, $L)"</span>,</div><div class="line">                   tableColumnInfoClassName,</div><div class="line">                   variableInfo.name,</div><div class="line">                   tableColumnInfoClassName,</div><div class="line">                   variableInfo.typeName.toString() + <span class="string">".class"</span>,</div><div class="line">                   column.name(),</div><div class="line">                   column.nullable(),</div><div class="line">......</div><div class="line"></div><div class="line">           );</div><div class="line">           initListBuilder.addStatement(<span class="string">"columnInfoList.add(info_$L)"</span>, variableInfo.name);</div><div class="line">       &#125;</div><div class="line">       MethodSpec initList = initListBuilder.build();</div><div class="line"></div><div class="line">   <span class="comment">// save方法</span></div><div class="line">       MethodSpec.Builder saveBuilder = MethodSpec.methodBuilder(<span class="string">"save"</span>)</div><div class="line">               .addAnnotation(Override.class)</div><div class="line">               .addModifiers(Modifier.PUBLIC)</div><div class="line">               .returns(<span class="keyword">long</span>.class)</div><div class="line">               .addParameter(modelClassName, <span class="string">"model"</span>)</div><div class="line">               .addStatement(<span class="string">"$T contentValues = new $T()"</span>, contentValueClassName, contentValueClassName);</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Table.Column, VariableInfo&gt; entry : columnMap.entrySet()) &#123;</div><div class="line">           Table.Column column = entry.getKey();</div><div class="line">           VariableInfo variableInfo = entry.getValue();</div><div class="line">           <span class="comment">// 自增字段不主动赋值</span></div><div class="line">           <span class="keyword">if</span> (!column.isAutoincrement()) &#123;</div><div class="line">               saveBuilder.addStatement(<span class="string">"contentValues.put($S, $L)"</span>, column.name(),</div><div class="line">                       getVariableGetter(variableInfo.name, variableInfo.typeName));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       saveBuilder.addStatement(<span class="string">"if (database == null) &#123;getDatabase();&#125;"</span>);</div><div class="line">       saveBuilder.addStatement(<span class="string">"return database.insert(tableName, null, contentValues)"</span>);</div><div class="line">       MethodSpec save = saveBuilder.build();</div><div class="line">......</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>上述代码通过<a href="https://github.com/square/javapoet" target="_blank" rel="external">javapoet</a>来生成java代码，遍历传进来的所有column名称以及类型，生成了<code>initColumnInfoList</code>和<code>save</code>方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initColumnInfoList</span><span class="params">()</span> </span>&#123;</div><div class="line">   columnInfoList = <span class="keyword">new</span> ArrayList();</div><div class="line">   TableColumnInfo info_name = <span class="keyword">new</span> TableColumnInfo(java.lang.String.class, <span class="string">"name"</span>, <span class="keyword">true</span>, <span class="string">"unknown"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="string">""</span>, <span class="keyword">new</span> String[]&#123;&#125;, -<span class="number">2147483648</span>);</div><div class="line">   columnInfoList.add(info_name);</div><div class="line">   TableColumnInfo info_isMale = <span class="keyword">new</span> TableColumnInfo(<span class="keyword">boolean</span>.class, <span class="string">"male"</span>, <span class="keyword">true</span>, <span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="string">""</span>, <span class="keyword">new</span> String[]&#123;&#125;, -<span class="number">2147483648</span>);</div><div class="line">   columnInfoList.add(info_isMale);</div><div class="line">   TableColumnInfo info_id = <span class="keyword">new</span> TableColumnInfo(java.lang.String.class, <span class="string">"id"</span>, <span class="keyword">true</span>, <span class="string">""</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="string">""</span>, <span class="keyword">new</span> String[]&#123;&#125;, -<span class="number">2147483648</span>);</div><div class="line">   columnInfoList.add(info_id);</div><div class="line">   TableColumnInfo info_age = <span class="keyword">new</span> TableColumnInfo(<span class="keyword">int</span>.class, <span class="string">"age"</span>, <span class="keyword">true</span>, <span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="string">""</span>, <span class="keyword">new</span> String[]&#123;&#125;, -<span class="number">2147483648</span>);</div><div class="line">   columnInfoList.add(info_age);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">save</span><span class="params">(User model)</span> </span>&#123;</div><div class="line">   ContentValues contentValues = <span class="keyword">new</span> ContentValues();</div><div class="line">   contentValues.put(<span class="string">"name"</span>, model.getName());</div><div class="line">   contentValues.put(<span class="string">"male"</span>, model.isMale());</div><div class="line">   contentValues.put(<span class="string">"id"</span>, model.getId());</div><div class="line">   contentValues.put(<span class="string">"age"</span>, model.getAge());</div><div class="line">   <span class="keyword">if</span> (database == <span class="keyword">null</span>) &#123;getDatabase();&#125;;</div><div class="line">   <span class="keyword">return</span> database.insert(tableName, <span class="keyword">null</span>, contentValues);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>initColumnInfoList构造了columnInfoList，有了他自然可以建表了，而save方法很清晰就是常用的一个插入操作了。</p><p>当然，生成代码的initColumnInfoList方法还是需要通过反射来调一次。</p><p>这样优化后，效率大幅提升，数据表插入效率提升30%，查询效率提升60%。</p><p>再总结下，其实大部分依赖反射的实现就都可以通过代码生成来解决。代码生成提高了库本身的复杂度，也增加了使用者的编译速度，但是相比性能的大幅提示来说，还是非常值得的。</p><p>写完回头看看觉得有点杂糅，因为既涉及到orm的实现，又涉及到注解处理。有空再单独写篇注解处理吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很早的时候因为业务的需要，找不到一款合适的orm框架，当时自己写了一个。很长时间过去了，一直想对这个orm库做一次性能优化，换掉原有的反射的注解处理方式，而是通过代码生成，从而大幅提高性能。&lt;/p&gt;
&lt;p&gt;原有的orm库通过反射的注解处理方式来实现。原有的Table注解声明
      
    
    </summary>
    
    
      <category term="orm, Annotation Processing, 注解处理" scheme="http://foocoder.com/tags/orm-Annotation-Processing-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用vim开发react native的环境搭建</title>
    <link href="http://foocoder.com/2016/04/08/vim%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://foocoder.com/2016/04/08/vim环境搭建/</id>
    <published>2016-04-08T09:45:03.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>续费博客域名的时候发现，一晃竟然两年没更新了……只能说时间过的真是好快。前几天把博客切换到了hexo，因为octopress的构建速度实在是已经不能支持继续写更多的博客了。</p><p>最近有时间就会去研究下react native，打算接下来写一系列react native相关的文章。</p><p>写react编辑器自然还是用我最喜欢的vim，可以配置下语法高亮，语法检查和代码片段自动生成。<br><a id="more"></a></p><p>###代码高亮<br>react特有的jsx使得必然需要特定的一个代码高亮插件，推荐<a href="https://github.com/mxw/vim-jsx" target="_blank" rel="external">vim-jsx</a>。不说支持的多么好吧，基本够用了。效果如图：<br><img src="http://77flrh.com1.z0.glb.clouddn.com/屏幕快照%202016-04-08%20下午5.38.43.png" alt=""></p><p>在Bundle配置中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bundle &apos;mxw/vim-jsx&apos;</div></pre></td></tr></table></figure><p>在vimrc中增加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let g:jsx_ext_required = 0</div></pre></td></tr></table></figure><p>从而使该插件在.js文件中也生效。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>之前写的最后一篇介绍vim插件的博客正好介绍的就是syntastic这个语法检查神器。<br>react的语法检查配合syntastic使用<code>ESLint</code>来完成。<br>分别安装eslint, babel-eslint (ES6支持)以及<a href="https://github.com/yannickcr/eslint-plugin-react" target="_blank" rel="external">eslint-plugin-react</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install -g eslint</div><div class="line">npm install -g babel-eslint</div><div class="line">npm install -g eslint-plugin-react</div></pre></td></tr></table></figure><p>安装完成后在根目录下新建<code>~/.eslintrc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class="line">    &quot;env&quot;: &#123;</div><div class="line">        &quot;browser&quot;: true,</div><div class="line">        &quot;node&quot;: true</div><div class="line">    &#125;,</div><div class="line">    &quot;settings&quot;: &#123;</div><div class="line">        &quot;ecmascript&quot;: 6,</div><div class="line">        &quot;jsx&quot;: true</div><div class="line">    &#125;,</div><div class="line">    &quot;plugins&quot;: [</div><div class="line">        &quot;react&quot;</div><div class="line">    ],</div><div class="line">    &quot;rules&quot;: &#123;</div><div class="line">        &quot;strict&quot;: 0,</div><div class="line">        &quot;quotes&quot;: 0,</div><div class="line">        &quot;no-unused-vars&quot;: 0,</div><div class="line">        &quot;camelcase&quot;: 0,</div><div class="line">        &quot;no-underscore-dangle&quot;: 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，设置Syntastic使用eslint：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let g:syntastic_javascript_checkers = [&apos;eslint&apos;]</div></pre></td></tr></table></figure><p>具体的规则支持可以去<a href="https://github.com/yannickcr/eslint-plugin-react#list-of-supported-rules" target="_blank" rel="external">eslint-plugin-react</a>查看。<br>效果如图：<br><img src="http://77flrh.com1.z0.glb.clouddn.com/屏幕快照%202016-04-08%20下午5.39.04.png" alt=""></p><p>###代码片段自动生成<br>之前介绍插件的博客有一个强大的插件还没介绍，那就是<a href="https://github.com/SirVer/ultisnips" target="_blank" rel="external">ultisnips</a>，用来完成自动的代码片段生成，用好的话还是能大幅提高编码速度的。用该插件结合不同语言的代码片段，就可以实现特定语言的代码自动生成了。</p><p>react当然需要react特定的snippets,推荐<a href="https://github.com/justinj/vim-react-snippets" target="_blank" rel="external">vim-react-snippets</a></p><p>同时安装vim-react-snippets和Ultisnips：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot; vim-react-snippets:</div><div class="line">Bundle &quot;justinj/vim-react-snippets&quot;</div><div class="line"></div><div class="line">&quot; Ultisnips</div><div class="line">Bundle &quot;SirVer/ultisnips&quot;</div><div class="line"></div><div class="line">&quot; Other sets of snippets (optional):</div><div class="line">Bundle &quot;honza/vim-snippets&quot;</div></pre></td></tr></table></figure><p>最后的honza/vim-snippets里面包含了大量各种语言的代码片段,可以一并安装。<br>效果如图，输入cdm，<tab>即可：<br><img src="http://77flrh.com1.z0.glb.clouddn.com/reactsnps.gif" alt=""><br>vim-react-snippets中的所有代码片段快捷键可以在插件目录下的snippets/javascript.snippets中查看。</tab></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;续费博客域名的时候发现，一晃竟然两年没更新了……只能说时间过的真是好快。前几天把博客切换到了hexo，因为octopress的构建速度实在是已经不能支持继续写更多的博客了。&lt;/p&gt;
&lt;p&gt;最近有时间就会去研究下react native，打算接下来写一系列react native相关的文章。&lt;/p&gt;
&lt;p&gt;写react编辑器自然还是用我最喜欢的vim，可以配置下语法高亮，语法检查和代码片段自动生成。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim中的语法检查-syntastic</title>
    <link href="http://foocoder.com/2014/05/13/vimzhong-de-yu-fa-jian-cha-syntastic/"/>
    <id>http://foocoder.com/2014/05/13/vimzhong-de-yu-fa-jian-cha-syntastic/</id>
    <published>2014-05-13T11:29:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较忙，有几天没更新了。今天有个同事问我一个语法插件的问题，向他介绍了Sytanstic.vim。那今天就来介绍下这个必备的插件吧。</p><p>很多人喜欢IDE就是因为他的语法检查，有了<a href="https://github.com/scrooloose/syntastic" target="_blank" rel="external">Sytanstic.vim</a>,这个问题就不复存在了。（当然，仅仅是语法检查）</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>上一张官方图：</p><p><img src="http://foocoder.qiniudn.com/blog/syntasticsyntastic.png?token=hYfsyKwhHPe-Ga-1Hypx5F8CwimEywvTI8XdNpEm:z6zQYbdezgOYcKfzok7LEkuRDkg=:eyJTIjoiZm9vY29kZXIucWluaXVkbi5jb20vYmxvZy9zeW50YXN0aWNzeW50YXN0aWMucG5nIiwiRSI6MTQwMDA2ODU2N30=" alt=""></p><a id="more"></a><p>图片很清楚的介绍了插件功能：</p><ol><li>用location list 列出所有错误。</li><li>命令行窗口显示当前错误。</li><li>错误标记，有警告和错误。</li><li>鼠标悬停可以出现错误提示框</li><li>状态栏标记。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Sytanstic目前支持了大多数常用语言，但是并不都打包在插件当中，而是可以按需安装相关的语法检查工具。在<a href="https://github.com/scrooloose/syntastic/wiki/Syntax-Checkers" target="_blank" rel="external">wiki</a>页面可以看到所有的语法检查包。</p><p>以javascript为例。在安装完syntastic之后（推荐使用vundle），我选择使用jshint来作为js的语法检查工具。</p><p>首先安装：</p><pre><code>npm install jshint -g</code></pre><p>注意安装后jshint需要在系统环境变量中，否则需要指定path：</p><pre><code>g:syntastic_jshint_exec</code></pre><p>指定jshint的配置文件目录：</p><pre><code>g:syntastic_javascript_jshint_conf</code></pre><p>jshint的配置这里就不说了，参看<a href="http://jshint.com/docs/" target="_blank" rel="external">文档</a></p><p>这样js语法检查就可以工作了。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>当然也可以做一些简单的配置，比如设置为每次打开buffer就执行语法检查，而不只是在保存时：</p><pre><code>let g:syntastic_check_on_open = 1</code></pre><p>如果想使用多个检查器，可以这样写：</p><pre><code>let g:syntastic_php_checkers = [&apos;php&apos;, &apos;phpcs&apos;, &apos;phpmd&apos;]</code></pre><h2 id="错误跳转"><a href="#错误跳转" class="headerlink" title="错误跳转"></a>错误跳转</h2><p>syntastic使用location list来显示所有的错误，location list和quificfix 类似，包含了位置信息。</p><p>调起这个location list</p><pre><code>:Errors 或者 :lopen</code></pre><p>使用<code>:lne[xt]</code>和<code>:lp[revious]</code>就可以在错误间跳转。当然，如果用的多，可以做个mapping。</p><p>今天就介绍到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比较忙，有几天没更新了。今天有个同事问我一个语法插件的问题，向他介绍了Sytanstic.vim。那今天就来介绍下这个必备的插件吧。&lt;/p&gt;
&lt;p&gt;很多人喜欢IDE就是因为他的语法检查，有了&lt;a href=&quot;https://github.com/scrooloose/syntastic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sytanstic.vim&lt;/a&gt;,这个问题就不复存在了。（当然，仅仅是语法检查）&lt;/p&gt;
&lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;p&gt;上一张官方图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://foocoder.qiniudn.com/blog/syntasticsyntastic.png?token=hYfsyKwhHPe-Ga-1Hypx5F8CwimEywvTI8XdNpEm:z6zQYbdezgOYcKfzok7LEkuRDkg=:eyJTIjoiZm9vY29kZXIucWluaXVkbi5jb20vYmxvZy9zeW50YXN0aWNzeW50YXN0aWMucG5nIiwiRSI6MTQwMDA2ODU2N30=&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim 重复操作的利器--点命令</title>
    <link href="http://foocoder.com/2014/05/06/vim-zhong-fu-cao-zuo-de-li-qi-dian-ming-ling/"/>
    <id>http://foocoder.com/2014/05/06/vim-zhong-fu-cao-zuo-de-li-qi-dian-ming-ling/</id>
    <published>2014-05-06T12:18:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/69d56e38gw1eg4vqmtvzsj20b408cdgf.jpg" alt=""></p><p>之前介绍过可以重复motion的插件space.vim，有朋友留言说<code>.</code>不是也可以？其实<code>.</code>确实可以重复很多动作，但是无法重复motion。其实<code>;</code>和<code>,</code>倒是可以重复motion。不过space.vim可以重复更多操作，之前的博客有全部列出来。</p><p>今天主要就介绍<code>.</code>命令。</p><p>这个命令就用来重复上一次的操作。比如:<code>dw</code>,再按<code>.</code>就会再删除一个单词。他可以重复的命令非常多，比如插入操作<code>a</code>,<code>i</code>，比如替换删除操作<code>c</code>,<code>s</code>, <code>r</code>还有<code>J</code>,<code>~</code>等常用的操作。但是我却很难概括他到底可以重复哪些操作，我基本归纳为重复对当前buffer造成改变的操作，虽然并不准确.</p><p>了解了基本的用途，来看看使用场景吧。我说说我一般的用法:</p><a id="more"></a><ol><li><code>ciw</code>替换文本，然后在另一个也需要替换相同文本的单词处按下<code>.</code>，就可以执行相同的替换操作。</li><li><code>dd</code>,<code>dw</code>,然后按下<code>.</code>就会再次删除一句或一个单词。我觉得连续输入<code>.</code>比数几秒有几个或几行比打<code>3dw/3dd</code>要更自然和更快，当然你觉得<code>3dw</code>更快也很正常.</li></ol><p>这两个是我用的最多的，每天必用。大家有其他好用的欢迎补充。</p><p>今天还要介绍一个插件，叫做<a href="https://github.com/tpope/vim-repeat" target="_blank" rel="external">repeat.vim</a>,和之前介绍过的surround.vim一样，来自tpope。repeat.vim做的事情很简单，重复一个插件操作，其中当然就支持surround.vim。这非常有用，比如给一个单词加了双引号，再按下<code>.</code>就可以也为另一个单词加上了。</p><p>repeat.vim还支持：</p><ul><li><a href="https://github.com/tpope/vim-speeddating" target="_blank" rel="external">speeddating.vim</a></li><li><a href="https://github.com/tpope/vim-abolish" target="_blank" rel="external">abolish.vim</a></li><li><a href="https://github.com/tpope/vim-unimpaired" target="_blank" rel="external">unimpaired.vim</a></li><li><a href="https://github.com/tpope/vim-commentary" target="_blank" rel="external">commentary.vim</a></li></ul><p>其中unimpaired.vim我也在用，下次可以介绍下。</p><p>今天就介绍到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/69d56e38gw1eg4vqmtvzsj20b408cdgf.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前介绍过可以重复motion的插件space.vim，有朋友留言说&lt;code&gt;.&lt;/code&gt;不是也可以？其实&lt;code&gt;.&lt;/code&gt;确实可以重复很多动作，但是无法重复motion。其实&lt;code&gt;;&lt;/code&gt;和&lt;code&gt;,&lt;/code&gt;倒是可以重复motion。不过space.vim可以重复更多操作，之前的博客有全部列出来。&lt;/p&gt;
&lt;p&gt;今天主要就介绍&lt;code&gt;.&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;这个命令就用来重复上一次的操作。比如:&lt;code&gt;dw&lt;/code&gt;,再按&lt;code&gt;.&lt;/code&gt;就会再删除一个单词。他可以重复的命令非常多，比如插入操作&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;i&lt;/code&gt;，比如替换删除操作&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;s&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;还有&lt;code&gt;J&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;等常用的操作。但是我却很难概括他到底可以重复哪些操作，我基本归纳为重复对当前buffer造成改变的操作，虽然并不准确.&lt;/p&gt;
&lt;p&gt;了解了基本的用途，来看看使用场景吧。我说说我一般的用法:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--平滑滚动accelerated-smooth-scroll.vim</title>
    <link href="http://foocoder.com/2014/04/29/mei-ri-vimcha-jian-ping-hua-gun-dong-accelerated-smooth-scroll-dot-vim/"/>
    <id>http://foocoder.com/2014/04/29/mei-ri-vimcha-jian-ping-hua-gun-dong-accelerated-smooth-scroll-dot-vim/</id>
    <published>2014-04-29T14:11:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个简单的插件：<a href="https://github.com/yonchu/accelerated-smooth-scroll" target="_blank" rel="external">accelerated-smooth-scroll.</a><br>很简单，就是让<code>&lt;C-D&gt;/&lt;C-U&gt;</code>和<code>&lt;C-F&gt;/&lt;C-B&gt;</code>不再突然出现，而是出现滚动效果。同时，在连续滚动时，还有加速效果。<br>做了个gif图，真实效果比图片要更流畅一些，如图所示：</p><p><img src="http://ww4.sinaimg.cn/large/69d56e38gw1efwtsjauuag20qj0ivkjm.gif" alt=""></p><p>今天就介绍它啦。几乎是用的最多的插件……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天介绍一个简单的插件：&lt;a href=&quot;https://github.com/yonchu/accelerated-smooth-scroll&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;accelerated-smooth-scroll.&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--强大的自动补全neocomplete.vim和supertab</title>
    <link href="http://foocoder.com/2014/04/28/mei-ri-vimcha-jian-qiang-da-de-zi-dong-bu-quan-neocomplete-dot-vim/"/>
    <id>http://foocoder.com/2014/04/28/mei-ri-vimcha-jian-qiang-da-de-zi-dong-bu-quan-neocomplete-dot-vim/</id>
    <published>2014-04-28T13:02:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>#neocomplete.vim</p><p>今天介绍两个个必备的vim插件，自动补全插件——<a href="https://github.com/Shougo/neocomplete.vim" target="_blank" rel="external">neocomplete.vim</a>和superTab。</p><p>neocomplete.vim是来自shougo的作品。该插件维护了当前buffer的一个关键词列表，从而提供强大的关键词补全功能。</p><p>该插件是他前作neocomplcache的升级版，速度更快，功能更强大。不过该插件需要<a href="http://vimdoc.sourceforge.net/htmldoc/if_lua.html" target="_blank" rel="external">if_lua</a>的支持。</p><p>mac下安装：</p><pre><code>brew install macvim --with-cscope --with-lua --HEAD</code></pre><p>或者不用macvim（真的不用么？赶紧试试吧）：</p><pre><code>brew install vim --with-lua</code></pre><p>不需要过多的介绍,看作者给的图：</p><a id="more"></a><h3 id="文件补全"><a href="#文件补全" class="headerlink" title="文件补全"></a>文件补全</h3><p><img src="https://f.cloud.github.com/assets/41495/622454/f519f6b8-cf42-11e2-921e-6e34dba148a6.png" alt="Original filename completion."><br><img src="https://f.cloud.github.com/assets/214488/623151/284ad86e-cf5b-11e2-828e-257d31bf0572.png" alt="Include filename completion."></p><h3 id="Omni-补全"><a href="#Omni-补全" class="headerlink" title="Omni 补全"></a>Omni 补全</h3><p><img src="https://f.cloud.github.com/assets/41495/622456/fb2cc0bc-cf42-11e2-94e8-403cdcf5427e.png" alt="Omni completion."></p><h3 id="vimshell补全"><a href="#vimshell补全" class="headerlink" title="vimshell补全"></a><a href="http://github.com/Shougo/vimshell" target="_blank" rel="external">vimshell</a>补全</h3><p><img src="https://f.cloud.github.com/assets/41495/622458/01dbc660-cf43-11e2-85f1-326e7432b0a1.png" alt="Completion with vimshell(http://github.com/Shougo/vimshell)."></p><h3 id="Vim-补全"><a href="#Vim-补全" class="headerlink" title="Vim 补全"></a>Vim 补全</h3><p><img src="https://f.cloud.github.com/assets/41495/622457/fe90ad5e-cf42-11e2-8e03-8f189b5e26e5.png" alt="Vim completion."><br><img src="https://f.cloud.github.com/assets/214488/623496/94ed19a2-cf68-11e2-8d33-3aad8a39d7c1.gif" alt="Vim completion with animation."></p><p>作者还给出了推荐配置，每个配置都有对应的英文注释，我就不一一翻译了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!</span></div><div class="line"><span class="comment">" Disable AutoComplPop.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:acp_enableAtStartup</span> = <span class="number">0</span></div><div class="line"><span class="comment">" Use neocomplete.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#enable_at_startup = <span class="number">1</span></div><div class="line"><span class="comment">" Use smartcase.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#enable_smart_case = <span class="number">1</span></div><div class="line"><span class="comment">" Set minimum syntax keyword length.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#sources#syntax#min_keyword_length = <span class="number">3</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#lock_buffer_name_pattern = <span class="string">'\*ku\*'</span></div><div class="line"></div><div class="line"><span class="comment">" Define dictionary.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#sources#dictionary#dictionaries = &#123;</div><div class="line">    \ <span class="string">'default'</span> : <span class="string">''</span>,</div><div class="line">    \ <span class="string">'vimshell'</span> : $HOME.<span class="string">'/.vimshell_hist'</span>,</div><div class="line">    \ <span class="string">'scheme'</span> : $HOME.<span class="string">'/.gosh_completions'</span></div><div class="line">        \ &#125;</div><div class="line"></div><div class="line"><span class="comment">" Define keyword.</span></div><div class="line"><span class="keyword">if</span> !exists(<span class="string">'g:neocomplete#keyword_patterns'</span>)</div><div class="line">    <span class="keyword">let</span> <span class="variable">g:neocomplete</span>#keyword_patterns = &#123;&#125;</div><div class="line"><span class="keyword">endif</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#keyword_patterns[<span class="string">'default'</span>] = <span class="string">'\h\w*'</span></div><div class="line"></div><div class="line"><span class="comment">" Plugin key-mappings.</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;C-g&gt;</span>     neocomplete#undo_completion()</div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;C-l&gt;</span>     neocomplete#complete_common_string()</div><div class="line"></div><div class="line"><span class="comment">" Recommended key-mappings.</span></div><div class="line"><span class="comment">" &lt;CR&gt;: close popup and save indent.</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;CR&gt;</span> <span class="symbol">&lt;C-r&gt;</span>=<span class="symbol">&lt;SID&gt;</span>my_cr_function()<span class="symbol">&lt;CR&gt;</span></div><div class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">my_cr_function</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">return</span> neocomplete#close_popup() . <span class="string">"\&lt;CR&gt;"</span></div><div class="line">  <span class="comment">" For no inserting &lt;CR&gt; key.</span></div><div class="line">  <span class="string">"return pumvisible() ? neocomplete#close_popup() : "</span>\<span class="symbol">&lt;CR&gt;</span><span class="comment">"</span></div><div class="line"><span class="keyword">endfunction</span></div><div class="line"><span class="comment">" &lt;TAB&gt;: completion.</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;TAB&gt;</span>  <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-n&gt;"</span> : <span class="string">"\&lt;TAB&gt;"</span></div><div class="line"><span class="comment">" &lt;C-h&gt;, &lt;BS&gt;: close popup and delete backword char.</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;C-h&gt;</span> neocomplete#smart_close_popup().<span class="string">"\&lt;C-h&gt;"</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;BS&gt;</span> neocomplete#smart_close_popup().<span class="string">"\&lt;C-h&gt;"</span></div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;C-y&gt;</span>  neocomplete#close_popup()</div><div class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;C-e&gt;</span>  neocomplete#cancel_popup()</div><div class="line"><span class="comment">" Close popup by &lt;Space&gt;.</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;Space&gt; pumvisible() ? neocomplete#close_popup() : "</span>\<span class="symbol">&lt;Space&gt;</span><span class="comment">"</span></div><div class="line"></div><div class="line"><span class="comment">" For cursor moving in insert mode(Not recommended)</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;Left&gt;  neocomplete#close_popup() . "</span>\<span class="symbol">&lt;Left&gt;</span><span class="comment">"</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;Right&gt; neocomplete#close_popup() . "</span>\<span class="symbol">&lt;Right&gt;</span><span class="comment">"</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;Up&gt;    neocomplete#close_popup() . "</span>\<span class="symbol">&lt;Up&gt;</span><span class="comment">"</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;Down&gt;  neocomplete#close_popup() . "</span>\<span class="symbol">&lt;Down&gt;</span><span class="comment">"</span></div><div class="line"><span class="comment">" Or set this.</span></div><div class="line"><span class="comment">"let g:neocomplete#enable_cursor_hold_i = 1</span></div><div class="line"><span class="comment">" Or set this.</span></div><div class="line"><span class="comment">"let g:neocomplete#enable_insert_char_pre = 1</span></div><div class="line"></div><div class="line"><span class="comment">" AutoComplPop like behavior.</span></div><div class="line"><span class="comment">"let g:neocomplete#enable_auto_select = 1</span></div><div class="line"></div><div class="line"><span class="comment">" Shell like behavior(not recommended).</span></div><div class="line"><span class="comment">"set completeopt+=longest</span></div><div class="line"><span class="comment">"let g:neocomplete#enable_auto_select = 1</span></div><div class="line"><span class="comment">"let g:neocomplete#disable_auto_complete = 1</span></div><div class="line"><span class="string">"inoremap &lt;expr&gt;&lt;TAB&gt;  pumvisible() ? "</span>\<span class="symbol">&lt;Down&gt;</span><span class="string">" : "</span>\<span class="symbol">&lt;C-x&gt;</span>\<span class="symbol">&lt;C-u&gt;</span><span class="comment">"</span></div><div class="line"></div><div class="line"><span class="comment">" Enable omni completion.</span></div><div class="line"><span class="keyword">autocmd</span> FileType css <span class="keyword">setlocal</span> omnifunc=csscomplete#CompleteCSS</div><div class="line"><span class="keyword">autocmd</span> FileType html,markdown <span class="keyword">setlocal</span> omnifunc=htmlcomplete#CompleteTags</div><div class="line"><span class="keyword">autocmd</span> FileType javascript <span class="keyword">setlocal</span> omnifunc=javascriptcomplete#CompleteJS</div><div class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">setlocal</span> omnifunc=pythoncomplete#Complete</div><div class="line"><span class="keyword">autocmd</span> FileType xml <span class="keyword">setlocal</span> omnifunc=xmlcomplete#CompleteTags</div><div class="line"></div><div class="line"><span class="comment">" Enable heavy omni completion.</span></div><div class="line"><span class="keyword">if</span> !exists(<span class="string">'g:neocomplete#sources#omni#input_patterns'</span>)</div><div class="line">  <span class="keyword">let</span> <span class="variable">g:neocomplete</span>#sources#omni#input_patterns = &#123;&#125;</div><div class="line"><span class="keyword">endif</span></div><div class="line"><span class="comment">"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]-&gt;\h\w*\|\h\w*::'</span></div><div class="line"><span class="comment">"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|-&gt;\)'</span></div><div class="line"><span class="comment">"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|-&gt;\)\|\h\w*::'</span></div><div class="line"></div><div class="line"><span class="comment">" For perlomni.vim setting.</span></div><div class="line"><span class="comment">" https://github.com/c9s/perlomni.vim</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:neocomplete</span>#sources#omni#input_patterns.<span class="keyword">perl</span> = <span class="string">'\h\w*-&gt;\h\w*\|\h\w*::'</span></div></pre></td></tr></table></figure><p>没有特殊需求，直接copy就用即可。没有复杂的配置，用起来还是非常简单的。</p><p>还有一个比较出名的补全插件是<a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">YouCompleteMe</a>.大家也可以去看下，应该是现在用的最广泛的补全插件了。我很早就试用过，还是neocomplete要更顺手更快些，总感觉neocomplete要更智能些。</p><p>#superTab</p><p>说到补全还有个不得不说，那就是tab键，必须用tab来进行补全那才是补全啊。其实neocomplete的推荐配置已经配置成了自动提示补全文字，并且支持tab选择，但是还是无法<code>shift-tab</code>回退选择。superTab就是为增强tab而生，当然可以做到这点。</p><p>superTab 和neocomplete一样，几乎不用自己折腾什么配置，也不用过多的介绍，一句话就可以说完它的功能。</p><pre><code>barbazb*&lt;Tab&gt; (*为光标所在位置) </code></pre><p>按示例在光标处按下tab，就会展开推荐补全bar和baz，按tab即可进行循环选择。</p><p>可以配置supertab的默认补全类型（对vim补全不了解的同学自己补下omni补全相关知识，需要我介绍可以回复下）：</p><pre><code>let g:SuperTabDefaultCompletionType = &quot;&lt;c-x&gt;&lt;c-u&gt;&quot;</code></pre><p>示例把supertab修改为了用户补全，默认是<code>&lt;c-p&gt;</code>.</p><p>今天就介绍到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#neocomplete.vim&lt;/p&gt;
&lt;p&gt;今天介绍两个个必备的vim插件，自动补全插件——&lt;a href=&quot;https://github.com/Shougo/neocomplete.vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;neocomplete.vim&lt;/a&gt;和superTab。&lt;/p&gt;
&lt;p&gt;neocomplete.vim是来自shougo的作品。该插件维护了当前buffer的一个关键词列表，从而提供强大的关键词补全功能。&lt;/p&gt;
&lt;p&gt;该插件是他前作neocomplcache的升级版，速度更快，功能更强大。不过该插件需要&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/if_lua.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;if_lua&lt;/a&gt;的支持。&lt;/p&gt;
&lt;p&gt;mac下安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install macvim --with-cscope --with-lua --HEAD
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者不用macvim（真的不用么？赶紧试试吧）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install vim --with-lua
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不需要过多的介绍,看作者给的图：&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--Gist.vim</title>
    <link href="http://foocoder.com/2014/04/25/mei-ri-vimcha-jian-gist-dot-vim/"/>
    <id>http://foocoder.com/2014/04/25/mei-ri-vimcha-jian-gist-dot-vim/</id>
    <published>2014-04-25T11:58:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efs6kvu5zpj20m80go3z0.jpg" alt=""><br>今天介绍的插件<a href="https://github.com/mattn/gist-vim" target="_blank" rel="external">Gist.vim</a>能够在vim中方便的创建和查看gist。</p><p>gist我就不过多介绍了，github提供的一个代码片段托管服务。不太了解的同学可以看看<a href="http://www.worldhello.net/gotgithub/06-side-projects/gist.html" target="_blank" rel="external">这个教程</a></p><p>要使用这个插件需要安装ygie依赖插件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bundle <span class="string">'mattn/webapi-vim'</span></div><div class="line">Bundle <span class="string">'mattn/gist-vim'</span></div></pre></td></tr></table></figure><p>确保在git的global配置中设置的是github用户名：</p><pre><code>$ git config --global github.user &lt;username&gt;</code></pre><p>该插件在首次使用时会需要你输入github密码来获取token，并将其保存在<code>~/.gist-vim</code>.</p><a id="more"></a><p>使用非常的简单，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist</div></pre></td></tr></table></figure><p>就会将该整个文件创建一个Gist，创建成功后会显示Gist地址，如图：<br><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efs60clnedj20my040gm2.jpg" alt=""></p><p>也可以选中一段代码创建Gist：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:&apos;&lt;,&apos;&gt;Gist</div></pre></td></tr></table></figure><p>还提供了一些参数</p><p>例如<code>-a</code>,表示匿名创建，<code>-p</code>创建pravite 的gist，<code>-P</code>创建public的gist。<code>-m</code>为所有打开的buffer创建Gist。</p><p>除此之外，还可以编辑Gist(已打开了一个gist buffer的情况下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -e</div></pre></td></tr></table></figure><p>加上描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -s something</div></pre></td></tr></table></figure><p>删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -d</div></pre></td></tr></table></figure><p>fork:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -f</div></pre></td></tr></table></figure><p>star:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist +1</div></pre></td></tr></table></figure><p>unstar:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -1</div></pre></td></tr></table></figure><p>还可以直接取得Gist：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist XXXXX</div></pre></td></tr></table></figure><p>一般你不记得gist号码，没关系，还可以列出所有的Gist,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:Gist -l</div></pre></td></tr></table></figure><p>这样会打开一个新的分隔窗口显示你已有的gist列表，按回车就可以直接去取这个gist并在vim中查看了。</p><p>还提供了一些非常有用的配置，比如：</p><p>如果你想要在创建了gist后立刻打开浏览器查看：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:gist_open_browser_after_post</span> = <span class="number">1</span></div></pre></td></tr></table></figure><p>如果想要默认创建的gist不是public而是private：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:gist_post_private</span> = <span class="number">1</span></div></pre></td></tr></table></figure><p>有了这个插件，玩转gist是不是非常easy啦。这个插件唯一的不足在于在创建gist或者请求gist时会阻塞界面，这个有点糟糕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/69d56e38gw1efs6kvu5zpj20m80go3z0.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;今天介绍的插件&lt;a href=&quot;https://github.com/mattn/gist-vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gist.vim&lt;/a&gt;能够在vim中方便的创建和查看gist。&lt;/p&gt;
&lt;p&gt;gist我就不过多介绍了，github提供的一个代码片段托管服务。不太了解的同学可以看看&lt;a href=&quot;http://www.worldhello.net/gotgithub/06-side-projects/gist.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要使用这个插件需要安装ygie依赖插件：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Bundle &lt;span class=&quot;string&quot;&gt;&#39;mattn/webapi-vim&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Bundle &lt;span class=&quot;string&quot;&gt;&#39;mattn/gist-vim&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;确保在git的global配置中设置的是github用户名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global github.user &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该插件在首次使用时会需要你输入github密码来获取token，并将其保存在&lt;code&gt;~/.gist-vim&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--代码搜索ack.vim/ag/ctlsf.vim</title>
    <link href="http://foocoder.com/2014/04/24/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim/"/>
    <id>http://foocoder.com/2014/04/24/mei-ri-vimcha-jian-dai-ma-sou-suo-ctlsf-dot-vim/</id>
    <published>2014-04-24T11:11:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>#ack.vim</p><p><a href="https://github.com/petdance/ack" target="_blank" rel="external">ack.vim</a>。应该是大多数vimer的必装插件。</p><p>在写这篇文章的时候才发现ack已经发布了2.0版本，并且ack 1已经不再维护。但是两者差别不大。这里介绍的基于2.0版本。</p><p>ack就是一个代码搜索工具，类似grep，用perl编写，充分利用了perl对正则的强大处理能力。为什么用ack而不是直接用grep？ack号称超越了grep。我基本认同。</p><ol><li>ack会显示搜索到的行号列号。</li><li>会自动忽略.git这样的文件类型。</li><li>速度很快。</li><li>最重要的是相对grep是一个文本搜索工具，ack就是一个代码搜索工具。你只会搜索到你的js文件，php文件，而不会搜到一些意外的文件类型。</li></ol><a id="more"></a><p>再也不用这样输入：</p><pre><code>grep foo $(find . -name &apos;*.pm&apos; | grep -v .svn)</code></pre><p>ack的使用很简单，命令输入：</p><pre><code>ack [OPTION]... PATTERN [FILES OR DIRECTORIES]</code></pre><p>如果不输入文件或者文件夹，则默认在当前目录及子目录下搜索。</p><p>ack大致有如下几类OPTION，</p><ol><li>搜索选项，例如-i, –ignore-case ，忽略pattern的大小写</li><li>搜索结果处理选项，例如 -l，只打印有匹配的文件名。</li><li>搜索输出展现选项，例如–heading，在头部输出匹配文件的文件名</li><li>文件搜索，是的，他还是find。例如 <code>Ack -f servicemodel</code> 查找servicemodel相匹配的文件。</li><li>文件过滤。例如 –[no]ignore-dir=name  从待搜索目录中添加或删除目录。</li></ol><p>具体的option可以查看ack文档.</p><p>这些option都可以直接配置到.ackrc中，作为默认配置。全局的ackrc放置于<code>/etc/ackrc</code>,用户的放在<code>$HOME/.ackrc</code>,仅仅用于某项目的就放在项目根目录中。</p><p>ack搜索结果如图所示：</p><p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efr1w9s9i8j21kw0ghafr.jpg" alt=""></p><p>会打开Quickfix窗口。显示文件名，对于的行列和该行内容。按<code>t</code>可以在新标签打开，按回车直接打开，按v分隔垂直窗口打开等等。和前天介绍的NERD Tree等大多数插件的操作类似。</p><h1 id="ag-vim"><a href="#ag-vim" class="headerlink" title="ag.vim"></a>ag.vim</h1><p>ack的用法就介绍到这里，这里还要介绍的是<a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ag</a>.和ack没什么区别，只是更快。</p><p>OS X下安装：</p><pre><code>brew install the_silver_searcher</code></pre><p>在vim中进行配置：</p><pre><code>let g:ackprg = &apos;ag --nogroup --nocolor --column&apos;</code></pre><p>也可以直接安装<a href="https://github.com/rking/ag.vim" target="_blank" rel="external">ag.vim</a>.ack 的 Silver Searcher fork版本。</p><h1 id="ctrlsf-vim"><a href="#ctrlsf-vim" class="headerlink" title="ctrlsf.vim"></a>ctrlsf.vim</h1><p>作者原图：</p><p><img src="https://camo.githubusercontent.com/fae368edf534ce2228eda41418cb55ee68e19c20/687474703a2f2f692e696d6775722e636f6d2f6d6c576a336d7a2e676966" alt=""></p><p>在安装了ack或者ag的基础上再安装该插件即可。正如它的名字，它提供了和sublime text 2中Ctrl-Shift-F 一样的搜索效果。和ack或者ag不同的是，不再是显示一行，而是显示整个上下文。非常好用。</p><p>除此之外，可以按下<code>p</code>进行预览，运行<code>:CtrlSFOpen</code>重新打开搜索结果窗口(默认选择后关闭搜索窗口)。这个插件也是来自国内的朋友。</p><p>今天就介绍到这。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#ack.vim&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/petdance/ack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ack.vim&lt;/a&gt;。应该是大多数vimer的必装插件。&lt;/p&gt;
&lt;p&gt;在写这篇文章的时候才发现ack已经发布了2.0版本，并且ack 1已经不再维护。但是两者差别不大。这里介绍的基于2.0版本。&lt;/p&gt;
&lt;p&gt;ack就是一个代码搜索工具，类似grep，用perl编写，充分利用了perl对正则的强大处理能力。为什么用ack而不是直接用grep？ack号称超越了grep。我基本认同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ack会显示搜索到的行号列号。&lt;/li&gt;
&lt;li&gt;会自动忽略.git这样的文件类型。&lt;/li&gt;
&lt;li&gt;速度很快。&lt;/li&gt;
&lt;li&gt;最重要的是相对grep是一个文本搜索工具，ack就是一个代码搜索工具。你只会搜索到你的js文件，php文件，而不会搜到一些意外的文件类型。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--命令行补全cmdline-completion</title>
    <link href="http://foocoder.com/2014/04/23/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion/"/>
    <id>http://foocoder.com/2014/04/23/mei-ri-vimcha-jian-ming-ling-xing-bu-quan-cmdline-completion/</id>
    <published>2014-04-23T13:57:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个非常实用简单的插件，叫做<a href="https://github.com/vim-scripts/cmdline-completion" target="_blank" rel="external">cmdline-completion</a>.功能就和名字描述的一样，在输入命令的时候，提供补全功能。vim自身对一些命令有补全功能，该插件对其进行了增强。比如：</p><ol><li>:something<c-p></c-p></li><li><p>/else<c-n></c-n></p><p>也可以自定义快捷键进行补全：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cmap</span> <span class="symbol">&lt;C-J&gt;</span> <span class="symbol">&lt;Plug&gt;</span>CmdlineCompletionBackward </div><div class="line"><span class="keyword">cmap</span> <span class="symbol">&lt;C-K&gt;</span> <span class="symbol">&lt;Plug&gt;</span>CmdlineCompletionForward</div></pre></td></tr></table></figure></li></ol><p> 今天的介绍非常简短，希望大家喜欢。有问题可以回复给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天介绍一个非常实用简单的插件，叫做&lt;a href=&quot;https://github.com/vim-scripts/cmdline-completion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cmdline-completion&lt;/a&gt;.功能就和名
      
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--文件浏览器NERD Tree以及git-nerdtree,vim-nerdtree-tabs</title>
    <link href="http://foocoder.com/2014/04/22/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs/"/>
    <id>http://foocoder.com/2014/04/22/mei-ri-vimcha-jian-wen-jian-liu-lan-qi-nerd-treeyi-ji-git-nerdtree-vim-nerdtree-tabs/</id>
    <published>2014-04-22T11:43:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个必备插件——<a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">NERD Tree</a>。这个插件基本用vim的都会知道吧。看图就知道了：<br><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efoqvqpramj21gu12i46s.jpg" alt=""></p><p>用它可以让vim像其他大多数编辑器或者IDE一样，打开一个分割窗口显示文件树，在这个文件树上可以通过<code>j</code>,<code>k</code>上下浏览以及其他一些快捷键进行快速文件导航。按回车就直接打开该文件，当然还可以通过<code>i</code>,<code>s</code>,<code>t</code>在分隔窗口或者在新标签页打开.</p><a id="more"></a><p>NERD Tree还支持书签。所谓书签，就是标记该文件或文件夹会优先显示在最上方。如前面图中的_posts文件夹。只要光标在该文件上输入命令<code>:Bookmark &lt;name&gt;</code>.非常方便</p><p>NERD Tree不想介绍过多，使用非常简单。在NerdTree窗口按下问号就会有帮助信息介绍所有的操作和对应的快捷键，常用下很快就很熟了。</p><p>NERD Tree有个问题在于和大多数IDE或者编辑器不同的是，在新的Tab中，NERD Tree默认是不打开的。不同的tab不能共享一个NERD Tree窗口，有人对这种方式可能就比较别扭。这时候就诞生了<a href="https://github.com/jistr/vim-nerdtree-tabs" target="_blank" rel="external">vim-nerdtree-tabs</a>.该插件就解决了这个问题，它让每个tab都有相同的NERD Tree，看起来就像NERD Tree固定在最左一样。按下<code>:NERDTreeTabsToggle</code>就可以打开或关闭所有窗口。关闭文件窗口的时候，对于tab的NERD Tree窗口也会自动关闭。</p><p>接下来介绍的<a href="https://github.com/Xuyuanp/git-nerdtree" target="_blank" rel="external">git-nerdtree</a>是来自@Xuyuanp的作品,通过微信公众号介绍给我。也是对NERD Tree的增强修改，增加了文件的git状态显示，和昨天的gitgutter类似，Gitgutter显示文件内的git diff，而git-nerdtree为NERD Tree增加了文件git状态的显示：</p><p><img src="https://camo.githubusercontent.com/3fe0388df11cb787f36e1fa108398fd3f757eef4/687474703a2f2f692e696d6775722e636f6d2f6a534377476a552e6769663f31" alt=""></p><p>相对应的标识如下：</p><ul><li><code>✭</code> / <code>*</code> : Untracked</li><li><code>✹</code> / <code>~</code> : Modified in the working tree</li><li><code>✚</code> / <code>+</code> : Staged in the index (Exclude Renamed status)</li><li><code>➜</code> / <code>»</code> : Renamed</li><li><code>═</code> / <code>=</code> : Unmerged</li><li><code>✖</code> / <code>-</code> : Deleted (This indicator can’t be shown, as NERDTree doesn’t display deleted files. I have no prefect idea to solve this problem currently.)</li><li><code>✗</code> / <code>×</code> : Dirty (Only for directory)</li><li><code>✔</code> / <code>ø</code> : Clean (Only for directory)</li></ul><p>标识方式和我之前介绍的zsh配置对git库状态的处理类似（可以查看我之前的博客）。</p><p>同时还支持和gitgutter一样的快捷键在各个有状态的文件之间跳转<code>[c</code>,<code>]c</code>.我只能说太棒了，再次感谢@Xuyuanp。</p><p>今天就介绍到这里，任何问题都可以直接回复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍一个必备插件——&lt;a href=&quot;https://github.com/scrooloose/nerdtree&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NERD Tree&lt;/a&gt;。这个插件基本用vim的都会知道吧。看图就知道了：&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/69d56e38gw1efoqvqpramj21gu12i46s.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用它可以让vim像其他大多数编辑器或者IDE一样，打开一个分割窗口显示文件树，在这个文件树上可以通过&lt;code&gt;j&lt;/code&gt;,&lt;code&gt;k&lt;/code&gt;上下浏览以及其他一些快捷键进行快速文件导航。按回车就直接打开该文件，当然还可以通过&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;t&lt;/code&gt;在分隔窗口或者在新标签页打开.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--显示git diff:GitGutter.vim</title>
    <link href="http://foocoder.com/2014/04/21/mei-ri-vimcha-jian-xian-shi-git-diff-gitgutter-dot-vim/"/>
    <id>http://foocoder.com/2014/04/21/mei-ri-vimcha-jian-xian-shi-git-diff-gitgutter-dot-vim/</id>
    <published>2014-04-21T12:44:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末休息了两天。今天继续。今天介绍的是一个可以显示git diff状态的插件——<a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="external">vim-gitgutter</a>.</p><p>所谓显示diff状态，看一张图大家就明白了<br><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efni76kr62j20po0os78b.jpg" alt=""></p><a id="more"></a><p>看最左边的标记列，一看就应该明白了。波浪线表示该行相比HEAD修改过，红色的减号表示这里删除了一行，绿色的+号表示这些行都是新增的。</p><p>这样git diff直接就一目了然，对自己的修改就更清晰了。</p><p>Gitgutter还支持在每个diff区块之间跳转（像图中就分了3块）。默认快捷键为<code>[c</code>和<code>]c</code>。可以非常方便地在各diff之间跳转了。</p><p>当然必须可以自定义mapping：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">nmap</span> ]h <span class="symbol">&lt;Plug&gt;</span>GitGutterNextHunk</div><div class="line"><span class="keyword">nmap</span> [h <span class="symbol">&lt;Plug&gt;</span>GitGutterPrevHunk</div></pre></td></tr></table></figure><p>Gitgutter不仅能显示这些git diff，还能暂存<code>&lt;Leader&gt;hs</code>和回退<code>&lt;Leader&gt;hr</code>修改。</p><p>同样支持自定义mapping：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">ha</span> <span class="symbol">&lt;Plug&gt;</span>GitGutterStageHunk</div><div class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;Leader&gt;</span>hu <span class="symbol">&lt;Plug&gt;</span>GitGutterRevertHunk</div></pre></td></tr></table></figure></p><p>不过这个我用的不是很多，暂时没感觉需要这样细粒度的执行暂存操作。</p><p>但是查看diff的修改我会比较常用，快捷键<code>&lt;Leader&gt;hp</code>,他会显示diff差异。如图所示：</p><p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efnire8hi2j20va0po0yl.jpg" alt=""></p><p>gitgutter还支持自定义git diff的参数，比如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:gitgutter_diff_args</span> = <span class="string">'-w'</span></div></pre></td></tr></table></figure><p>就介绍这么多了。btw，感觉用了gitgutter，Gundo的会变得略微慢一点。但是，Gitgutter显然是必备插件啊。有问题直接回复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末休息了两天。今天继续。今天介绍的是一个可以显示git diff状态的插件——&lt;a href=&quot;https://github.com/airblade/vim-gitgutter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vim-gitgutter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;所谓显示diff状态，看一张图大家就明白了&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69d56e38gw1efni76kr62j20po0os78b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--快速选择文本对象wildfile.vim</title>
    <link href="http://foocoder.com/2014/04/18/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim/"/>
    <id>http://foocoder.com/2014/04/18/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim/</id>
    <published>2014-04-18T12:06:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了文本对象，并介绍了两个自定义文本对象的插件。今天介绍的插件也和文本对象有关。他可以用来快速的就近选择一个候选文本对象，并能通过快捷键继续简单的扩大文本对象范围。</p><p>这个插件就是–<a href="https://github.com/Shougo/wildfire.vim" target="_blank" rel="external">wildfire</a>（给的是shougo fork的repo地址，比较喜欢shougo这个插件作者，而且这个fork fix了一个bug）</p><p>插件默认定义的候选文本对象为：</p><pre><code>`i&apos;`, `i&quot;`, `i)`, `i]`, `i}`, `ip` and `it`</code></pre><p>来一张官方图</p><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efk07xfk7kg20jv087myy.gif" alt=""></p><p>有图应该大家能理解这个插件的作用了。</p><p>使用方式也非常简单，按<code>enter</code>选择最近一个文本对象，再按下<code>enter</code>在刚刚的选择之上再选择最近的文本对象。按下<code>&lt;BS&gt;</code>就能回退到上一个选择。</p><p>当然，你可以自定义快捷键：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" This selects the next closest text object.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:wildfire_fuel_map</span> = <span class="string">"&lt;ENTER&gt;"</span></div><div class="line"></div><div class="line"><span class="comment">" This selects the previous closest text object.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:wildfire_water_map</span> = <span class="string">"&lt;BS&gt;"</span></div></pre></td></tr></table></figure><p>候选的文本对象也是可以配置的：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:wildfire_objects</span> = [<span class="string">"i'"</span>, <span class="string">'i"'</span>, <span class="string">"i)"</span>, <span class="string">"i]"</span>, <span class="string">"i&#125;"</span>, <span class="string">"ip"</span>, <span class="string">"it"</span>]</div></pre></td></tr></table></figure><p>插件还支持对文件类型分别定义，比如要在html中只处理tag，忽略其他文本对象，只需要配置：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" use '*' to mean 'all other filetypes'</span></div><div class="line"><span class="comment">" in this example, html and xml share the same text objects</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:wildfire_objects</span> = &#123;</div><div class="line">    \ <span class="string">"*"</span> : [<span class="string">"i'"</span>, <span class="string">'i"'</span>, <span class="string">"i)"</span>, <span class="string">"i]"</span>, <span class="string">"i&#125;"</span>, <span class="string">"ip"</span>],</div><div class="line">    \ <span class="string">"html,xml"</span> : [<span class="string">"at"</span>],</div><div class="line">\ &#125;</div></pre></td></tr></table></figure><p>与之类似的一个用的相当广泛的插件还有<a href="https://github.com/terryma/vim-expand-region" target="_blank" rel="external">vim-expand-region</a>。大家可以自己选择。有问题欢迎留言或回复交流。也希望大家推荐自己在用，自己写的插件给我。今天看到一个朋友微信回复我的一个他自己写的插件，我已经立刻用上了，卖个关子，下次介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍了文本对象，并介绍了两个自定义文本对象的插件。今天介绍的插件也和文本对象有关。他可以用来快速的就近选择一个候选文本对象，并能通过快捷键继续简单的扩大文本对象范围。&lt;/p&gt;
&lt;p&gt;这个插件就是–&lt;a href=&quot;https://github.com/Shougo/wildfire.vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wildfire&lt;/a&gt;（给的是shougo fork的repo地址，比较喜欢shougo这个插件作者，而且这个fork fix了一个bug）&lt;/p&gt;
&lt;p&gt;插件默认定义的候选文本对象为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`i&amp;apos;`, `i&amp;quot;`, `i)`, `i]`, `i}`, `ip` and `it`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来一张官方图&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--可以重复motion的space.vim</title>
    <link href="http://foocoder.com/2014/04/17/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim/"/>
    <id>http://foocoder.com/2014/04/17/mei-ri-vimcha-jian-zhong-fu-motion-space-dot-vim/</id>
    <published>2014-04-17T13:10:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/69d56e38gw1efiwusn0uhj20m80godg5.jpg" style="height: 400px;"></p><p>今天头疼的厉害。不过昨天没更新，今天必须有了。介绍个简单点的。</p><p>vim中在普通模式下，空格这么大一按键不用有点浪费，所以有了<a href="https://github.com/spiiph/vim-space" target="_blank" rel="external">space.vim</a>.</p><a id="more"></a><p>他能重复执行motion，比如</p><pre><code>*Hello World</code></pre><p>按下<code>fo</code>,会将光标移动到第一个o上，再按下空格，就能移动到第二个o了，他会重复执行上一个<code>fo</code>。按下<code>&lt;Shift-Space&gt;</code>反向执行改操作，也就是光标又会回到第一个<code>o</code>.</p><p>除此之外，space.vim还能重复搜索命令，diff移动命令，qucikfix等操作。让空格键变的非常有用.下面是space.vim可以重复的全部命令列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">Character movements:                                    |left-right-motions|</div><div class="line">    |f| |F| |t| |T| |;| |,|</div><div class="line"></div><div class="line">Search commands:                                           |search-commands|</div><div class="line">    |star| |gstar| |#| |g#| |n| |N|</div><div class="line"></div><div class="line">Jump list jumps:                                              |jump-motions|</div><div class="line">    |CTRL-O| |CTRL-I|</div><div class="line"></div><div class="line">Change list jumps:                                       |change-list-jumps|</div><div class="line">    |g;| |g,|</div><div class="line"></div><div class="line">Diff jumps:                                                   |jumpto-diffs|</div><div class="line">    |]c| |[c|</div><div class="line"></div><div class="line">Parenthesis and bracket jumps:                             |various-motions|</div><div class="line">    |])| |[(| |]&#125;| |[&#123;|</div><div class="line"></div><div class="line">Method jumps:                                              |various-motions|</div><div class="line">    |]m| |[m| |]M| |[M|</div><div class="line"></div><div class="line">Section jumps:                                              |object-motions|</div><div class="line">    |]]| |[]| |][| |[[|</div><div class="line"></div><div class="line">Fold movements:</div><div class="line">    |zj| |zk| |]z| |[z|</div><div class="line"></div><div class="line">Tag movements:                                                |tag-commands|</div><div class="line">    |CTRL-]|</div><div class="line">    |:tag|</div><div class="line">    |:tnext|</div><div class="line">    |:tprevious|</div><div class="line">    |:tNext|</div><div class="line">    |:trewind|</div><div class="line">    |:tfirst|</div><div class="line">    |:tlast|</div><div class="line"></div><div class="line">Undolist movements:                                          |undo-branches|</div><div class="line">    |g-||g+|</div><div class="line"></div><div class="line">Quickfix commands:                                                |quickfix|</div><div class="line">    |:make|</div><div class="line">    |:vimgrep|</div><div class="line">    |:grep|</div><div class="line">    |:cc|</div><div class="line">    |:cnext|</div><div class="line">    |:cprevious|</div><div class="line">    |:cNext|</div><div class="line">    |:cfirst|</div><div class="line">    |:clast|</div><div class="line">    |:crewind|</div><div class="line">    |:cfile|</div><div class="line">    |:cnfile|</div><div class="line">    |:cpfile|</div><div class="line">    |:cNfile|</div><div class="line"></div><div class="line">Location list commands:                                      |location-list|</div><div class="line">    |:lmake|</div><div class="line">    |:lvimgrep|</div><div class="line">    |:lgrep|</div><div class="line">    |:ll|</div><div class="line">    |:lcnext|</div><div class="line">    |:lcprevious|</div><div class="line">    |:lcNext|</div><div class="line">    |:lcfirst|</div><div class="line">    |:lclast|</div><div class="line">    |:lcrewind|</div><div class="line">    |:lcfile|</div><div class="line">    |:lcnfile|</div><div class="line">    |:lcpfile|</div><div class="line">    |:lcNfile|</div></pre></td></tr></table></figure><p>今天解介绍到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/69d56e38gw1efiwusn0uhj20m80godg5.jpg&quot; style=&quot;height: 400px;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天头疼的厉害。不过昨天没更新，今天必须有了。介绍个简单点的。&lt;/p&gt;
&lt;p&gt;vim中在普通模式下，空格这么大一按键不用有点浪费，所以有了&lt;a href=&quot;https://github.com/spiiph/vim-space&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;space.vim&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--vim 撤销树Gundo.vim</title>
    <link href="http://foocoder.com/2014/04/15/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim/"/>
    <id>http://foocoder.com/2014/04/15/mei-ri-vimcha-jian-vim-che-xiao-shu-gundo-dot-vim/</id>
    <published>2014-04-15T13:10:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍的插件很有意思，也非常有用，也是我最常用的插件之一——<a href="https://github.com/sjl/gundo.vim" target="_blank" rel="external">Gundo</a>.</p><p>大家都知道按<code>u</code>可以撤销操作，但是一般都不知道输入命令<code>:undolist</code>会显示可撤销列表，如图</p><p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efglaef02lj20ki13qthg.jpg" style="    height: 600px;"> </p><p>其实这还不是列表，而是整个vim 撤销树的叶子。为什么说是树，而不是列表，举个例子就明白了：</p><a id="more"></a><p>你在a状态做了一次修改到b，又回退到a，再做了一次修改到c。大多数编辑器比如sublime text，b这个状态就没了，但是vim会用一个树进行保存。</p><p>而Gundo这个插件就是一个撤销树浏览器.直接上张图：</p><p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efgmev2lz4j20ok1ci78i.jpg" style="    height: 600px;"></p><p>当前位置以<code>@</code>标注，其他历史以o标注。</p><p>按jk上下移动，就可以在下面的窗口看到对应修改之前的改动。这个就是普通的vim窗口，所有的移动操作都是支持的，比如<code>G</code>到底部，<code>C-U</code>上翻页等。</p><p>按<code>p</code>可以查看选中状态和当前状态的差异，按回车就会回到选中状态，按<code>P</code>更是可以一步步播放到选中状态，高上大啊……</p><p>btw,我习惯将所有的undo记录都保存下来，即使关闭了vim或者buffer也能继续撤销。</p><p>只需要稍加配置，就能将撤销树持久化存储下来：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">    <span class="keyword">set</span> undodir=~/.<span class="keyword">vim</span>/temp_dirs/undodir</div><div class="line">    <span class="keyword">set</span> <span class="built_in">undofile</span></div><div class="line"><span class="keyword">catch</span></div><div class="line"><span class="keyword">endtry</span></div></pre></td></tr></table></figure><p>今天就介绍到这里。有问题直接回复给我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍的插件很有意思，也非常有用，也是我最常用的插件之一——&lt;a href=&quot;https://github.com/sjl/gundo.vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gundo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;大家都知道按&lt;code&gt;u&lt;/code&gt;可以撤销操作，但是一般都不知道输入命令&lt;code&gt;:undolist&lt;/code&gt;会显示可撤销列表，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69d56e38gw1efglaef02lj20ki13qthg.jpg&quot; style=&quot;
    height: 600px;
&quot;&gt; &lt;/p&gt;
&lt;p&gt;其实这还不是列表，而是整个vim 撤销树的叶子。为什么说是树，而不是列表，举个例子就明白了：&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--vim中的文本对象及相关插件</title>
    <link href="http://foocoder.com/2014/04/14/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian/"/>
    <id>http://foocoder.com/2014/04/14/mei-ri-vimcha-jian-vimzhong-de-wen-ben-dui-xiang-ji-xiang-guan-cha-jian/</id>
    <published>2014-04-14T14:56:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天按读者留言的要求，介绍下文本对象。同时还会介绍我在用的几个文本相关的插件，今天是满满的内容啊。</p><p>所谓文本对象，简单来说就是以一定标准分隔符来标识一段文本，比如一个单词，一句话，一段话。</p><p>使用文本对象后你会发现你在vim中的移动和操作速度提升了不是一点半点。</p><p>在vim中编辑命令的结构如下：</p><pre><code>&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</code></pre><p>可以看到文本对象和motion的操作是完全一致的，第一个是数字，比如3w，就向前移动三个单词。</p><a id="more"></a><p>文本对象大致有以下几种：</p><pre><code>w  s  p &apos;&apos; &quot;&quot;  &lt;&gt;  []  ()  {} &lt;tag&gt;</code></pre><p>其中w表示word，s表示句子，p表示段落，其他的就是昨天介绍过的包围符号，标签用t表示。</p><p>文本对象的操作范围有两种，一种用<code>i</code>表示,是inner的意思，即不包括单词边上的空格符，亦或是<code>&lt;</code>包围符号本身。一种用<code>a</code>表示，是arround的意思，和i相反，使用a就包括了空格符或者包围符号本身。</p><p>文本对象的编辑命令就是vim中的几个常用编辑命令，分别是</p><pre><code>`y：复制`，`d：删除`,`c：替换`，`v：选中`</code></pre><p>说的有点多了，来几个例子相信大家就立刻理解了。（例子中*都是光标所在位置）</p><p>比如：</p><pre><code>&lt;*h2&gt;Sample Title&lt;/h2&gt;</code></pre><p>按下<code>cit</code>,文本变为：</p><pre><code>&lt;h2&gt;*&lt;/h2&gt;</code></pre><p>再比如：<br>    console.log(“stay hungry,” + “stay *foolish”)</p><p>按下<code>da&quot;</code>，文本变为：</p><pre><code>console.log(&quot;stay hungry,&quot; +*)</code></pre><p>再按下<code>di)</code>，文本变为：</p><pre><code>console.log()</code></pre><p>比如</p><pre><code>Hello Worl*d</code></pre><p>按下<code>diw</code>,文本变为：</p><pre><code>Hello</code></pre><p>很容易理解是不是？有没有发现为什么说文本对象会非常方便了？无论光标在文本的哪个位置，都可以直接操作整个文本。体验箭步如飞的感觉吧。</p><p>vim还允许使用脚本来自定义文本对象，这就是我们今天要介绍的插件了，这些插件自定义了一些文本对象。</p><p>1.CamelCaseMotion</p><p>该插件是把驼峰词语的每个单词分开，举个例子：</p><pre><code>get*ElementsByClassName</code></pre><p>按下<code>di,w</code>,则文本变为：</p><pre><code>getByClassName</code></pre><p>非常方便。</p><p>2.argtextobj</p><p>该插件定义了函数内的参数文本对象。比如：</p><pre><code>foo(text, ti*mes, option) {}</code></pre><p>按下<code>daa</code>,则文本变为：</p><pre><code>foo(text, option) {}</code></pre><p>今天暂时就介绍到这里。都快0点了，赶紧发出来。任何问题都可以回复给我。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天按读者留言的要求，介绍下文本对象。同时还会介绍我在用的几个文本相关的插件，今天是满满的内容啊。&lt;/p&gt;
&lt;p&gt;所谓文本对象，简单来说就是以一定标准分隔符来标识一段文本，比如一个单词，一句话，一段话。&lt;/p&gt;
&lt;p&gt;使用文本对象后你会发现你在vim中的移动和操作速度提升了不是一点半点。&lt;/p&gt;
&lt;p&gt;在vim中编辑命令的结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;number&amp;gt;&amp;lt;command&amp;gt;&amp;lt;text object or motion&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到文本对象和motion的操作是完全一致的，第一个是数字，比如3w，就向前移动三个单词。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--surround.vim</title>
    <link href="http://foocoder.com/2014/04/13/mei-ri-vimcha-jian-surround-dot-vim/"/>
    <id>http://foocoder.com/2014/04/13/mei-ri-vimcha-jian-surround-dot-vim/</id>
    <published>2014-04-13T14:11:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个必备的插件——<a href="https://github.com/tpope/vim-surround" target="_blank" rel="external">surround.vim</a>,来自Tim Pope大神，很多著名的插件包括pathogen.vim都是出自他手，后面我还会介绍更多他写的插件。</p><p>是我最常用的插件之一。这个插件专门用来处理成对的包围符号……比如说括号，单双引号，XML标签等。</p><p>使用也非常简单好记，遵循vim本身的规则。</p><p>先来看一组实例，就知道这个插件的用途和使用方式了：</p><p>光标在</p><pre><code>&quot;Hello world!&quot;</code></pre><p>中时按下<code>cs&quot;&#39;</code> ，则会替换双引号为单引号：</p><pre><code>&apos;Hello world!&apos;</code></pre><a id="more"></a><p>继续按下<code>cs&#39;&lt;q&gt;</code>，则会替换单引号为<q>标签</q></p><pre><code>&lt;q&gt;Hello world!&lt;/q&gt;</code></pre><p>按下 <code>cst&quot;</code>，则回到初始的双引号：</p><pre><code>&quot;Hello world!&quot;</code></pre><p>要删除符号，则按下<code>ds&quot;</code></p><pre><code>Hello world!</code></pre><p>当光标在hello上时，按下<code>ysiw]</code>，则会变为</p><pre><code>[Hello] world!</code></pre><p>这个操作为其加上了包围符号。</p><p>总结下：</p><p>1.删除包围符号的命令是<code>ds</code>,后面加的字符表示要删除的符号。比如：</p><pre><code>&quot;Hello *world!&quot;           ds&quot;         Hello world!</code></pre><p>2.替换包围符号的命令是<code>cs</code>,命令后跟两个参数，分别是被替换的符号和需要使用的符号。比如</p><pre><code>&quot;Hello *world!&quot;           cs&quot;&apos;        &apos;Hello world!&apos;</code></pre><p>3.添加包围符号的命令是<code>ys</code>(ys可以记为you surround)，命令后同样跟两个参数，第一个是一个vim“动作”（motion）或者是一个文本对象。</p><p>其中motion即vim动作，比如说<code>w</code>向后一个单词。文本对象简单的来说主要是来通过一些分隔符来标识一段文本，比如<code>iw</code>就是一个文本对象，即光标下的单词。不理解的朋友可以将光标放置在单词hello的中央，分别试一下<code>ysw</code>和<code>ysiw</code>的区别应该就明白啦。如果大家需要详细介绍motion和文本对象，可以留言或者直接公众账号回复，我看看要不要单独介绍下。</p><pre><code>Hello w*orld!             ysiw)       Hello (world)!</code></pre><p>另外：<code>yss</code>命令可以用于整行操作，忽略中间的空格。<br><code>yS</code>和<code>ySS</code>还能让包围内容单独一行并且加上缩进。</p><p>4.添加包围符号还有个非常好用的方式：在可视模式v下，按下<code>S</code>后即可添加想要添加的包围符号了。</p><p>再说一个小技巧：在包围符号为括时，输入左括号<code>(或者{</code>,则会留一个空格</p><pre><code>Hello w*orld!             ysiw(       Hello ( world )!</code></pre><p>而右括号则不留空格，也是非常好用，看编码风格使用。</p><p>今天就介绍到这里，欢迎关注我的公众账号，最新的文章都会第一时间推送到。有问题可以直接回复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍一个必备的插件——&lt;a href=&quot;https://github.com/tpope/vim-surround&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;surround.vim&lt;/a&gt;,来自Tim Pope大神，很多著名的插件包括pathogen.vim都是出自他手，后面我还会介绍更多他写的插件。&lt;/p&gt;
&lt;p&gt;是我最常用的插件之一。这个插件专门用来处理成对的包围符号……比如说括号，单双引号，XML标签等。&lt;/p&gt;
&lt;p&gt;使用也非常简单好记，遵循vim本身的规则。&lt;/p&gt;
&lt;p&gt;先来看一组实例，就知道这个插件的用途和使用方式了：&lt;/p&gt;
&lt;p&gt;光标在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中时按下&lt;code&gt;cs&amp;quot;&amp;#39;&lt;/code&gt; ，则会替换双引号为单引号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;Hello world!&amp;apos;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--缩进显示vim-indent-guides</title>
    <link href="http://foocoder.com/2014/04/11/mei-ri-vimcha-jian-suo-jin-xian-shi-vim-indent-guides/"/>
    <id>http://foocoder.com/2014/04/11/mei-ri-vimcha-jian-suo-jin-xian-shi-vim-indent-guides/</id>
    <published>2014-04-11T09:49:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天有朋友留言问昨天晒配色的图中缩进用的什么插件，那今天就介绍这个缩进插件——<a href="https://github.com/nathanaelkane/vim-indent-guides" target="_blank" rel="external">vim-indent-guides</a></p><p>选择这个插件主要有几个理由：</p><ol><li>插件对tab和空格的支持都很好。</li><li>比较美观。</li><li>能够自动适配当前使用的colorscheme来选择缩进颜色（只能是gvim，macvim下适配的不错）</li></ol><a id="more"></a><p>默认的快捷键是<code>&lt;Leader&gt;ig</code>,开关插件。我一般都默认启动就开启,只要设置：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_enable_on_vim_startup</span> = <span class="number">1</span></div></pre></td></tr></table></figure><p>前面说了缩进的颜色是自动选择的，非常方便，但是想要自定义颜色也是支持的：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_auto_colors</span> = <span class="number">0</span></div><div class="line"><span class="keyword">autocmd</span> VimEnter,Colorscheme * :<span class="keyword">hi</span> IndentGuidesOdd  guibg=<span class="keyword">red</span>   ctermbg=<span class="number">3</span></div><div class="line"><span class="keyword">autocmd</span> VimEnter,Colorscheme * :<span class="keyword">hi</span> IndentGuidesEven guibg=green ctermbg=<span class="number">4</span></div></pre></td></tr></table></figure><p>在终端中该插件就不支持颜色自动选择了。只取决于<code>background</code>设置为<code>dark</code>还是<code>light</code>,如果设置了<code>dark</code>,就相当于配置了</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">hi</span> IndentGuidesOdd  ctermbg=black</div><div class="line"><span class="keyword">hi</span> IndentGuidesEven ctermbg=darkgrey</div></pre></td></tr></table></figure><p>来几张图，图上标注了相应的配置：</p><p><img src="http://ww4.sinaimg.cn/large/69d56e38gw1efbth8m9aij20cg0cgta5.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efbtngrerjj20cg0cg3zt.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efbtqa6k47j20cg0cgjsq.jpg" alt=""></p><p>这个插件并不能很好的标记出tab和空格混用的情况，只能显示当前缩进。所以我在我的vimrc中加了一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot; highlight tabs and trailing spaces</div><div class="line">set list</div><div class="line">set listchars=tab:&gt;-,trail:-,extends:&gt;,precedes:&lt;</div></pre></td></tr></table></figure></p><p>这样tab会被显示为&gt;-，而尾部空格被显示为-，这样写出来的代码就不会再有杂乱符号啦。</p><p>今天就介绍到这里。我开通了一个微信公众账号，以后每天的文章会通过微信公众账号推送，欢迎关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有朋友留言问昨天晒配色的图中缩进用的什么插件，那今天就介绍这个缩进插件——&lt;a href=&quot;https://github.com/nathanaelkane/vim-indent-guides&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vim-indent-guides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择这个插件主要有几个理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插件对tab和空格的支持都很好。&lt;/li&gt;
&lt;li&gt;比较美观。&lt;/li&gt;
&lt;li&gt;能够自动适配当前使用的colorscheme来选择缩进颜色（只能是gvim，macvim下适配的不错）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--我的配色 molokai</title>
    <link href="http://foocoder.com/2014/04/10/mei-ri-vimcha-jian-wo-de-pei-se-molokai/"/>
    <id>http://foocoder.com/2014/04/10/mei-ri-vimcha-jian-wo-de-pei-se-molokai/</id>
    <published>2014-04-10T13:24:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天其实不介绍插件。因为有一些朋友问，所以今天单独介绍下我的配色和字体。</p><p>配色使用的是我钟爱的monokai，但是换了深色配色，使用了一个<a href="https://github.com/tomasr/molokai" target="_blank" rel="external">molokai</a>配色插件。之所以叫molokai，因为这个配色是monokai的修改版，将monokai的背景色改为了深色。我想要一个深色背景的molokai.正和我意啊。</p><p>下面是两张作者的原图：<br><a id="more"></a></p><p><img src="http://www.winterdom.com/weblog/content/binary/WindowsLiveWriter/MolokaiforVim_8602/molokai_normal_small_3.png" alt=""></p><p><img src="http://www.winterdom.com/weblog/content/binary/WindowsLiveWriter/MolokaiforVim_8602/molokai_original_small_3.png" alt=""></p><p>如果要使用monokai原始的背景色，加上配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let g:molokai_original = 1</div></pre></td></tr></table></figure><p>下面再放上一张我自己的图：<br><img src="http://ww1.sinaimg.cn/large/69d56e38gw1efatpzm085j21kw0zrdnu.jpg" alt=""></p><p>两者的差别除了缩进显示之外就是字体了。</p><p>字体也是我非常喜欢，精挑细选的字体<a href="https://github.com/adobe/source-code-pro" target="_blank" rel="external">Source code pro</a></p><p><img src="http://ww2.sinaimg.cn/large/69d56e38gw1efatye9ls3j20lw0haacp.jpg" alt=""></p><p>链接里有下载和安装方法，喜欢就试试吧。</p><hr><p>4月11号更新：<br>看到下面评论有晒自己的配色，想起来有个repo，里面收集了非常多的vim 配色。<br>这里也贴出来——<a href="https://github.com/flazz/vim-colorschemes" target="_blank" rel="external">vim-colorschemes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天其实不介绍插件。因为有一些朋友问，所以今天单独介绍下我的配色和字体。&lt;/p&gt;
&lt;p&gt;配色使用的是我钟爱的monokai，但是换了深色配色，使用了一个&lt;a href=&quot;https://github.com/tomasr/molokai&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;molokai&lt;/a&gt;配色插件。之所以叫molokai，因为这个配色是monokai的修改版，将monokai的背景色改为了深色。我想要一个深色背景的molokai.正和我意啊。&lt;/p&gt;
&lt;p&gt;下面是两张作者的原图：&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--vim-multiple-cursors</title>
    <link href="http://foocoder.com/2014/04/09/mei-ri-vimcha-jian-vim-multiple-cursors/"/>
    <id>http://foocoder.com/2014/04/09/mei-ri-vimcha-jian-vim-multiple-cursors/</id>
    <published>2014-04-09T14:19:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天清明休假了。每日插件也就休息了几天。不过休假搞的比上班还累……</p><p>今天介绍一款我用的非常多，也非常有用的插件–<a href="">vim-multiple-cursors</a>。</p><p>这个插件copy了sublime text的多重光标选取功能，非常强大。</p><p>sublime text 官网有几张图来介绍sublime text的多重选取功能，插件作者也实现了一样的效果：<br><img src="http://ww1.sinaimg.cn/large/69d56e38gw1ef9pr4t1i2g20k406ojtw.gif" alt=""></p><a id="more"></a><p>上图按键：</p><ul><li>fp跳到p处</li><li>按下<code>&lt;C-n&gt;</code>选中光标下的单词</li><li>继续按下<code>&lt;C-n&gt;</code>两次选中另外两个相同的单词</li><li>按下c进行修改</li><li>键入修改</li><li>按下 <code>&lt;Esc&gt;</code> 退出</li></ul><p><img src="http://ww1.sinaimg.cn/large/69d56e38gw1ef9pzm3d13g20sy0900zt.gif" alt=""></p><p>上图按键：</p><ul><li>按下V选中整行</li><li>按下G到达末行</li><li>按下<code>&lt;C-n&gt;</code> 在每行的开头加上一个光标并返回普通模式</li><li>按下I在每行的头部插入</li><li>键入”, 按下<code>&lt;C-e&gt;</code>到达行末, 键入另一个”和逗号</li><li>然后将每个光标都下移一行，按下delete    </li></ul><p>再也不用羡慕sublime了。</p><p>使用也非常简单，几乎0配置。</p><p>默认的mapping：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot; Default mapping</div><div class="line">let g:multi_cursor_next_key=&apos;&lt;C-n&gt;&apos;</div><div class="line">let g:multi_cursor_prev_key=&apos;&lt;C-p&gt;&apos;</div><div class="line">let g:multi_cursor_skip_key=&apos;&lt;C-x&gt;&apos;</div><div class="line">let g:multi_cursor_quit_key=&apos;&lt;Esc&gt;&apos;</div></pre></td></tr></table></figure><p>在普通模式下，按下<code>Ctrl-n</code>开始进入可视模式并选中光标下的单词，继续按<code>Ctrl-n</code>选择下一个相同的单词，按下<code>Ctrl-p</code>往回选一个，<code>Ctrl-x</code>则跳过下一个相同单词。</p><p>选中后就可以对单词进行批量改动了，比如按下c，就同时修改选中单词。</p><p>插件还支持正则匹配，不过要用到正则去匹配的时候我就用%s来替换了。要了解详情可以去插件的github页继续了解。</p><p>今天就介绍这个性感无比的插件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天清明休假了。每日插件也就休息了几天。不过休假搞的比上班还累……&lt;/p&gt;
&lt;p&gt;今天介绍一款我用的非常多，也非常有用的插件–&lt;a href=&quot;&quot;&gt;vim-multiple-cursors&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个插件copy了sublime text的多重光标选取功能，非常强大。&lt;/p&gt;
&lt;p&gt;sublime text 官网有几张图来介绍sublime text的多重选取功能，插件作者也实现了一样的效果：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69d56e38gw1ef9pr4t1i2g20k406ojtw.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>每日vim插件--goyo</title>
    <link href="http://foocoder.com/2014/04/03/mei-ri-vimcha-jian-goyo/"/>
    <id>http://foocoder.com/2014/04/03/mei-ri-vimcha-jian-goyo/</id>
    <published>2014-04-03T13:50:00.000Z</published>
    <updated>2017-11-06T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>一如既往很忙……所以今天还是分享一个可以一句话说明白的插件，也是我非常常用的–<a href="https://github.com/junegunn/goyo.vim" target="_blank" rel="external">goyo</a></p><p>一直非常喜欢写作软件iawriter，goyo让我可以用同样的方式来写代码，当然goyo还免费开源，这比iawriter好。用作者的描述就是：Distraction-free writing in Vim. 不会被任何的其他元素打扰。<br><a id="more"></a><br>直接上张图：<img src="http://ww4.sinaimg.cn/large/69d56e38gw1ef2r2wod9uj21kw0zkte6.jpg" alt=""><br><img src="https://raw.github.com/junegunn/i/master/goyo.png" alt=""></p><p>第一张是我的配色，第二张是作者的示例。是不是很cool？</p><p>安装当然借用vundle了。</p><pre><code>nnoremap &lt;Leader&gt;d :Goyo&lt;CR&gt;</code></pre><p>就可以按引导键加逗号呼出goyo模式了。<br>可以按自己的需求配置宽高和位置：</p><ul><li><code>g:goyo_width</code> (default: 80)</li><li><code>g:goyo_margin_top</code> (default: 4)</li><li><code>g:goyo_margin_bottom</code> (default: 4)</li><li><code>g:goyo_linenr</code> (default: 0)</li><li><code>g:goyo_callbacks</code> ([before_funcref, after_funcref])</li></ul><p>goyo模式中默认禁用了<br><a href="https://github.com/bling/vim-airline" target="_blank" rel="external">vim-airline</a>,<br><a href="https://github.com/Lokaltog/vim-powerline" target="_blank" rel="external">vim-powerline</a>,<br><a href="https://github.com/Lokaltog/powerline" target="_blank" rel="external">powerline</a>,<br><a href="https://github.com/itchyny/lightline.vim" target="_blank" rel="external">lightline.vim</a>, and<br><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="external">vim-gitgutter</a>插件。如果需要自定义goyo模式或者一些插件的enable/disable，</p><p>可以在vimrc中定义before和after回掉：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">goyo_before</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">silent</span> !tmux <span class="keyword">set</span> status off</div><div class="line">  <span class="keyword">set</span> noshowmode</div><div class="line">  <span class="keyword">set</span> noshowcmd</div><div class="line">  <span class="comment">" ...</span></div><div class="line"><span class="keyword">endfunction</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">goyo_after</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">silent</span> !tmux <span class="keyword">set</span> status <span class="keyword">on</span></div><div class="line">  <span class="keyword">set</span> showmode</div><div class="line">  <span class="keyword">set</span> showcmd</div><div class="line">  <span class="comment">" ...</span></div><div class="line"><span class="keyword">endfunction</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="variable">g:goyo_callbacks</span> = [<span class="function"><span class="keyword">function</span><span class="params">('s:goyo_before')</span>, <span class="title">function</span><span class="params">('s:goyo_after')</span>]</span></div></pre></td></tr></table></figure><p>可以在<a href="https://github.com/junegunn/goyo.vim/wiki/Customization" target="_blank" rel="external">这里</a>看到更多的自定义示例</p><p>好吧，基本就是翻译了一下……因为插件很简单，文档也很详细。我自己非常喜欢这个插件，希望大家也会喜欢～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一如既往很忙……所以今天还是分享一个可以一句话说明白的插件，也是我非常常用的–&lt;a href=&quot;https://github.com/junegunn/goyo.vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;goyo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一直非常喜欢写作软件iawriter，goyo让我可以用同样的方式来写代码，当然goyo还免费开源，这比iawriter好。用作者的描述就是：Distraction-free writing in Vim. 不会被任何的其他元素打扰。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="http://foocoder.com/categories/vim/"/>
    
    
  </entry>
  
</feed>
